pltdfm <- tail(tmpdfm_vi, n)
} else {
pltdfm <- tmpdfm_vi
}
# plotting
baseplt <- ggplot(pltdfm, aes(x = Target, y = Mean), environment = loclEnv) +
geom_bar(position="dodge", stat="identity", color="black", fill = "gray66")+
scale_x_discrete(expand = c(0.01, 0)) +
scale_y_continuous(expand = c(0.01, 0)) +
ggtitle(Title) +
xlab(yLabel) + # the arguments for x and y labls are switched as the figure will be rotated
ylab(xLabel) + # the arguments for x and y labls are switched as the figure will be rotated
geom_hline(yintercept = 0) +
theme(panel.background = element_rect(fill = 'white', colour = 'black'),
panel.border = element_rect(colour = "black", fill = NA, size = 0.5),
plot.title = element_text(hjust = 0.5),
legend.position = "bottom",
legend.title = element_blank(),
axis.text.x = element_text(size = xTxtSize, angle = 0, hjust = 0.5), # x and y not reversed as they are not associated with the roation of the axes.
axis.text.y = element_text(size = yTxtSize, hjust = 0.5)) +
coord_flip()
if (errorbar == "SEM"){
plt <- baseplt +
geom_errorbar(aes(ymin = Mean - SEM, ymax = Mean + SEM), width = errorbarWidth,
position = position_dodge(0.9))
} else if (errorbar == "SD") {
plt <- baseplt +
geom_errorbar(aes(ymin = Mean - SD, ymax = Mean + SD), width = errorbarWidth,
position = position_dodge(0.9))
}
## add the right-side y axis
grid.newpage()
# extract gtable
pltgtb <- ggplot_gtable(ggplot_build(plt))
# add the right side y axis
Aa <- which(pltgtb$layout$name == "axis-l")
pltgtb_a <- pltgtb$grobs[[Aa]]
axs <- pltgtb_a$children[[2]]
axs$widths <- rev(axs$widths)
axs$grobs <- rev(axs$grobs)
axs$grobs[[1]]$x <- axs$grobs[[1]]$x - unit(1, "npc") + unit(0.08, "cm")
Ap <- c(subset(pltgtb$layout, name == "panel", select = t:r))
pltgtb <- gtable_add_cols(pltgtb, pltgtb$widths[pltgtb$layout[Aa, ]$l], length(pltgtb$widths) - 1)
pltgtb <- gtable_add_grob(pltgtb, axs, Ap$t, length(pltgtb$widths) - 1, Ap$b)
# export the file and draw a preview
ggsave(filename = paste(objTitle,".vi.plot.pdf", sep = ""), plot = pltgtb,
width = plotWidth, height = plotHeight, units = "mm",dpi = 600)
grid.draw(pltgtb) # preview
}
## return the vi ranking and OOB err dataframes for the initial feature elimination
outlst <- list(matrix_initial_FS = training_initFS,
feature_initial_FS = feature_initFS,
recur_vi_summary = outdfm_vi,
recur_OOB_err_summary = outdfm_OOB_err)
sink(file = paste(objTitle,".initialFS.txt",sep = ""), append=FALSE) # dump the results to a file
print(outlst)
sink() # end dump
return(assign(paste(objTitle, "_inital_FS", sep = ""), outlst, envir = .GlobalEnv)) # return a dataframe with the vi ranking dataframe
}
rbioRF_initialFS(objTitle = "HCvTC", training_HCvTC, tgtVar_HCvTC, Title = "Variable Importance for HC vs TC",
multicore = TRUE)
phase0(objTitle = "HCvTC", training_HCvTC, tgtVar_HCvTC, Title = "Variable Importance for HC vs TC",
multicore = TRUE)
phase0 <- function(objTitle = "x_vs_tgt",
x, targetVar, nTimes = 50, nTree = 1001, mTry = max(floor(ncol(x) / 3), 2),
multicore = TRUE,
plot = TRUE, n = "all",
Title = NULL, xLabel = "Mean Decrease in Accuracy", yLabel = NULL,
errorbar = "SEM", errorbarWidth = 0.2,
xTxtSize = 10, yTxtSize =10,
plotWidth = 170, plotHeight = 150){
#### check the variables
if (ncol(x) == 1){
stop("only one variable detected.")
}
#### recursive RF
### load the dataframe/matrix
training <- as.matrix(x)
### pepare the target variable
tgt <- factor(as.character(targetVar), levels = unique(targetVar))
### prepare draw size. this uses down-sampling if the samples are unbalanced
nlvl <- length(levels(tgt))
size <- min(as.vector(table(tgt))) # down-sampling
drawSize <- rep(size, nlvl)
### repeating random forest - recursive approach
# pre-set an empty matrix with the number of columns same as the number of RF runs
# note that nrow is the number of features, hence the ncol of the training set
vimtx <- matrix(nrow = ncol(training), ncol = nTimes)
errmtx <- matrix(nrow = 1, ncol = nTimes)
if (!multicore){
## signle core computing: recursive structure
tmpFunc <- function(n, m, tmptimes, tmpvimtx, tmperrmtx, tmpTraining, tmpTgt,
tmpTree, tmpTry, tmpSize){
tmploclEnv <- environment() # save the environment local to tmpFunc
if (n == 0){
rownames(tmpvimtx) <- colnames(tmpTraining)
colnames(tmpvimtx) <- c(paste("vi", seq(m - 1), sep = "_"))
rownames(tmperrmtx) <- "OOB_error_rate"
colnames(tmperrmtx) <- c(paste("OOB_error_tree", seq(m - 1), sep = "_"))
tmplst <- list(raw_vi = tmpvimtx, raw_OOB_error = tmperrmtx)
return(tmplst)
} else {
rf <- randomForest(x = tmpTraining, y = tmpTgt, ntree = tmpTree, mtry = tmpTry, importance = TRUE,
proximity = TRUE, drawSize = tmpSize)
impt <- importance(rf, type = 1)
tmpvimtx[, m] <- impt[, 1] # fill the vi matrix
tmperrmtx[, m] <- rf$err.rate[tmptimes, 1] # fill the OOB error rate
tmpFunc(n - 1, m + 1, tmptimes, tmpvimtx, tmperrmtx, tmpTraining, tmpTgt,
tmpTree, tmpTry, tmpSize)
}
}
lst <- tmpFunc(n = nTimes, m = 1, tmptimes = nTree, tmpvimtx = vimtx, tmperrmtx = errmtx, tmpTraining = training, tmpTgt = tgt,
tmpTree = nTree, tmpTry = mTry, tmpSize = drawSize)
phase0mtx_vi <- lst$raw_vi
phase0mtx_OOB_err <- lst$raw_OOB_error
} else {
## parallel computing
# set up cpu cluster
n_cores <- detectCores() - 1
cl <- makeCluster(n_cores)
on.exit(stopCluster(cl)) # close connect when exiting the function
# recursive RF using par-apply functions
tmpfunc2 <- function(i, ...){
rf <- randomForest::randomForest(x = training, y = tgt, ntree = nTree, mtry = mTry, importance = TRUE,
proximity = TRUE, drawSize = drawSize)
impt <- randomForest::importance(rf, type = 1)
tmpvimtx <- impt[, 1] # fill the vi matrix
tmperrmtx <- rf$err.rate[nTree, 1] # fill the OOB error rate
lst <- list(tmpvimtx = tmpvimtx, tmperrmtx = tmperrmtx)
}
tmp <- parLapply(cl, X = 1:nTimes, fun = tmpfunc2)
for (j in 1:nTimes){
vimtx[, j] <- tmp[[j]]$tmpvimtx
errmtx[, j] <- tmp[[j]]$tmperrmtx
}
rownames(vimtx) <- colnames(training)
colnames(vimtx) <- c(paste("vi", seq(nTimes), sep = "_"))
rownames(errmtx) <- "OOB_error_rate"
colnames(errmtx) <- c(paste("OOB_error_tree", seq(nTimes), sep = "_"))
phase0mtx_vi <- vimtx
phase0mtx_OOB_err <- errmtx
}
####prepare output vi and OOB error dataframes
## prepare the vi dataframe
fName_vi <- rownames(phase0mtx_vi)
fMean_vi <- rowMeans(phase0mtx_vi)
fSD_vi <- apply(phase0mtx_vi, 1, sd)
fSEM_vi <- sapply(fSD_vi, function(x)x/sqrt(ncol(phase0mtx_vi)))
tmpdfm_vi <- data.frame(Target = fName_vi, Mean = fMean_vi, SD = fSD_vi, SEM = fSEM_vi, stringsAsFactors = FALSE)
tmpdfm_vi <- tmpdfm_vi[order(tmpdfm_vi$Mean), ]
tmpdfm_vi$Target <- factor(tmpdfm_vi$Target, levels = unique(tmpdfm_vi$Target))
fMean_OOB_err <- rowMeans(phase0mtx_OOB_err)
fSD_OOB_err <- apply(phase0mtx_OOB_err, 1, sd)
fSEM_OOB_err <- fSD_OOB_err/sqrt(ncol(phase0mtx_OOB_err))
# ranked vi dataframe
outdfm_vi <- data.frame(tmpdfm_vi[order(tmpdfm_vi$Mean, decreasing = TRUE), ],
Rank = c(1:nrow(tmpdfm_vi))) # make sure to resort the dataframe in descenting order.
# OOB dtaframe
outdfm_OOB_err <- data.frame(Mean = fMean_OOB_err, SD = fSD_OOB_err, SEM = fSEM_OOB_err, stringsAsFactors = FALSE)
rownames(outdfm_OOB_err) <- paste(nTimes, "trees_OOB_err", sep = "_")
## initial feature elimination
cartTree <- rpart(SD ~ Rank, data = outdfm_vi, cp = 0, minsplit = 2) # CART modelling: classify Rank by SD. Using ANOVA (regression) method.
mincp <- cartTree$cptable[which(cartTree$cptable[, 4] == min(cartTree$cptable[, 4])) ,1] # extract the minimum cp value
cartprune <- prune(cartTree, cp = mincp) # prune the tree so that SD values that won't impact Rank classfication are discarded
minpredv <- min(predict(cartprune)) # obatain the minimum prediciton value (predicted SD) as the SD threshold for Mean
if (length(which(outdfm_vi$Mean < minpredv)) == 0){ # in the case of VI values don't meet the cut.
thsd <- ncol(training)
} else {
thsd <- min(which(outdfm_vi$Mean < minpredv)) - 1 # compare Mean and SD. Discard all the features with a mean < minimum predicted SD.
}
feature_initFS <- as.character(outdfm_vi$Target[1:thsd]) # extract selected features
training_initFS <- training[, feature_initFS, drop = FALSE] # subsetting the input matrix
## vi plotting
if (plot){
loclEnv <- environment()
# prepare plotting dataframe
if (n != "all"){
pltdfm <- tail(tmpdfm_vi, n)
} else {
pltdfm <- tmpdfm_vi
}
# plotting
baseplt <- ggplot(pltdfm, aes(x = Target, y = Mean), environment = loclEnv) +
geom_bar(position="dodge", stat="identity", color="black", fill = "gray66")+
scale_x_discrete(expand = c(0.01, 0)) +
scale_y_continuous(expand = c(0.01, 0)) +
ggtitle(Title) +
xlab(yLabel) + # the arguments for x and y labls are switched as the figure will be rotated
ylab(xLabel) + # the arguments for x and y labls are switched as the figure will be rotated
geom_hline(yintercept = 0) +
theme(panel.background = element_rect(fill = 'white', colour = 'black'),
panel.border = element_rect(colour = "black", fill = NA, size = 0.5),
plot.title = element_text(hjust = 0.5),
legend.position = "bottom",
legend.title = element_blank(),
axis.text.x = element_text(size = xTxtSize, angle = 0, hjust = 0.5), # x and y not reversed as they are not associated with the roation of the axes.
axis.text.y = element_text(size = yTxtSize, hjust = 0.5)) +
coord_flip()
if (errorbar == "SEM"){
plt <- baseplt +
geom_errorbar(aes(ymin = Mean - SEM, ymax = Mean + SEM), width = errorbarWidth,
position = position_dodge(0.9))
} else if (errorbar == "SD") {
plt <- baseplt +
geom_errorbar(aes(ymin = Mean - SD, ymax = Mean + SD), width = errorbarWidth,
position = position_dodge(0.9))
}
## add the right-side y axis
grid.newpage()
# extract gtable
pltgtb <- ggplot_gtable(ggplot_build(plt))
# add the right side y axis
Aa <- which(pltgtb$layout$name == "axis-l")
pltgtb_a <- pltgtb$grobs[[Aa]]
axs <- pltgtb_a$children[[2]]
axs$widths <- rev(axs$widths)
axs$grobs <- rev(axs$grobs)
axs$grobs[[1]]$x <- axs$grobs[[1]]$x - unit(1, "npc") + unit(0.08, "cm")
Ap <- c(subset(pltgtb$layout, name == "panel", select = t:r))
pltgtb <- gtable_add_cols(pltgtb, pltgtb$widths[pltgtb$layout[Aa, ]$l], length(pltgtb$widths) - 1)
pltgtb <- gtable_add_grob(pltgtb, axs, Ap$t, length(pltgtb$widths) - 1, Ap$b)
# export the file and draw a preview
ggsave(filename = paste(objTitle,".vi.plot.pdf", sep = ""), plot = pltgtb,
width = plotWidth, height = plotHeight, units = "mm",dpi = 600)
grid.draw(pltgtb) # preview
}
## return the vi ranking and OOB err dataframes for the initial feature elimination
outlst <- list(matrix_initial_FS = training_initFS,
feature_initial_FS = feature_initFS,
recur_vi_summary = outdfm_vi,
recur_OOB_err_summary = outdfm_OOB_err)
sink(file = paste(objTitle,".initialFS.txt",sep = ""), append=FALSE) # dump the results to a file
print(outlst)
sink() # end dump
return(assign(paste(objTitle, "_inital_FS", sep = ""), outlst, envir = .GlobalEnv)) # return a dataframe with the vi ranking dataframe
}
Sys.time(phase0(objTitle = "HCvTC", training_HCvTC, tgtVar_HCvTC, Title = "Variable Importance for HC vs TC",
multicore = TRUE))
Sys.time(phase0(objTitle = "HCvTC", training_HCvTC, tgtVar_HCvTC, Title = "Variable Importance for HC vs TC",
multicore = TRUE))
system.time(phase0(objTitle = "HCvTC", training_HCvTC, tgtVar_HCvTC, Title = "Variable Importance for HC vs TC",
multicore = TRUE))
system.time(phase0(objTitle = "HCvPTSD", nTree = 501, training_HCvPTSD, tgtVar_HCvPTSD,
Title = "Variable Importance for HC vs PTSD", plotWidth = 230, plotHeight = 200))
HCvPTSD_inital_FS
phase1 <- function(objTitle = "x_vs_tgt",
x, targetVar, nTimes = 50, nTree = 1001, mTry = "recur_default",
multicore = TRUE,
plot = TRUE, n = "all",
Title = NULL, xLabel = NULL, yLabel = NULL,
errorbar = "SEM", errorbarWidth = 0.2,
symbolSize = 2, xTxtSize = 10, yTxtSize =10,
plotWidth = 170, plotHeight = 150
){
## prepare the dataframe
training <- data.frame(x, check.names = FALSE)
### pepare the target variable
tgt <- factor(as.character(targetVar), levels = unique(targetVar))
### prepare draw size. this uses down-sampling if the samples are unbalanced
nlvl <- length(levels(tgt))
size <- min(as.vector(table(tgt))) # down-sampling
drawSize <- rep(size, nlvl)
## prepare blank tree OOB error matrics
singleerrmtx <- matrix(nrow = 1, ncol = nTimes) # for the recursive OOB error rates from a single tree
ooberrmtx <- matrix(nrow = ncol(training), ncol = nTimes) # for the recursive OOB error rates from all trees.
if (!multicore){
## signle core computing: recursive structure
tmpFunc <- function(n, m, tmperrmtx, tmpTraining, tmpTgt,
tmpTree, tmpTry, tmpSize){
if (n == 0){
return(tmperrmtx)
} else {
if (tmpTry == "recur_default"){
if (ncol(tmpTraining) < 4){
rf <- randomForest(x = tmpTraining, y = tmpTgt, ntree = tmpTree, importance = TRUE,
proximity = TRUE, drawSize = tmpSize)
} else {
rf <- randomForest(x = tmpTraining, y = tmpTgt, ntree = tmpTree, mtry = max(floor(ncol(tmpTraining) / 3), 2),
importance = TRUE,
proximity = TRUE, drawSize = tmpSize)
}
} else if (tmpTry == "rf_default"){
rf <- randomForest(x = tmpTraining, y = tmpTgt, ntree = tmpTree,
importance = TRUE,
proximity = TRUE, drawSize = tmpSize)
} else {
stop("Please select a proper mtry setting")
}
tmperrmtx[, m] <- tail(rf$err.rate[, 1], n = 1) # fill the OOB error rate
tmpFunc(n - 1, m + 1, tmperrmtx, tmpTraining, tmpTgt,
tmpTree, tmpTry, tmpSize)
}
}
tmpFunc2 <- function(i, j, tmp2mtx, ...){
if (i == 0){
rownames(tmp2mtx) <- seq(j - 1)
colnames(tmp2mtx) <- c(paste("OOB_error_tree_rep", seq(nTimes), sep = "_"))
return(tmp2mtx)
} else {
tmp2mtx[j, ] <- tmpFunc(n = nTimes, m = 1, tmperrmtx = singleerrmtx,
tmpTraining = training[, 1:j, drop = FALSE], tmpTgt = tgt, tmpTree = nTree, tmpTry = mTry,
tmpSize = drawSize)
tmpFunc2(i - 1, j + 1, tmp2mtx, ...)
}
}
mtxforfunc2 <- ooberrmtx
ooberrmtx <- tmpFunc2(i = ncol(training), j = 1, tmp2mtx = mtxforfunc2) # j is the tree index
} else {
## parallel computing
# set up cpu cluster
n_cores <- detectCores() - 1
cl <- makeCluster(n_cores)
on.exit(stopCluster(cl)) # close connect when exiting the function
# recursive RF using par-apply functions
tmpfunc4 <- function(j, ...){
n_cores2 <- parallel::detectCores() - 1
cl2 <- parallel::makeCluster(n_cores2)
on.exit(parallel::stopCluster(cl2)) # close connect when exiting the function
tmpfunc3 <- function(i, ...){
if (mTry == "recur_default"){
if (j < 4){
rf <- randomForest::randomForest(x = training[, 1:j, drop = FALSE], y = tgt, ntree = nTree, importance = TRUE,
proximity = TRUE, drawSize = drawSize)
} else {
rf <- randomForest::randomForest(x = training[, 1:j, drop = FALSE], y = tgt, ntree = nTree, mtry = max(floor(ncol(training[1:j]) / 3), 2),
importance = TRUE,
proximity = TRUE, drawSize = drawSize)
}
} else if (mTry == "rf_default"){
rf <- randomForest::randomForest(x = training[, 1:j, drop = FALSE], y = tgt, ntree = nTree, importance = TRUE,
proximity = TRUE, drawSize = drawSize)
} else {
stop("Please select a proper mtry setting")
}
tmperrmtx <- tail(rf$err.rate[, 1], n = 1) # compute the OOB error rate
lst <- list(tmperrmtx = tmperrmtx)
}
errmtx <- matrix(nrow = 1, ncol = nTimes) # for the recursive OOB error rates from a single tree
tmp <- parallel::parLapply(cl2, X = 1:nTimes, fun = tmpfunc3)
for (p in 1:nTimes){
errmtx[, p] <- tmp[[p]]$tmperrmtx # fill the OOB error rate
}
list = list(errmtx = errmtx)
}
l <- parLapply(cl, X = 1:ncol(training), tmpfunc4)
for (q in 1:ncol(training)){
ooberrmtx[q, ] <- l[[q]]$errmtx
}
rownames(ooberrmtx) <- seq(ncol(training))
colnames(ooberrmtx) <- c(paste("OOB_error_tree_rep", seq(nTimes), sep = "_"))
}
## perpare the summary dataframe for OOB error rates
ooberrnames <- rownames(ooberrmtx)
ooberrmean <- rowMeans(ooberrmtx)
ooberrSD <- apply(ooberrmtx, 1, sd)
ooberrSEM <- sapply(ooberrSD, function(x)x / sqrt(ncol(ooberrmtx)))
ooberrsummary <- data.frame(Features = ooberrnames, Mean = ooberrmean, SD = ooberrSD,
SEM = ooberrSEM, stringsAsFactors = FALSE)
ooberrsummary$Features <- factor(ooberrsummary$Features, levels = unique(ooberrsummary$Features))
## output
minerrsd <- with(ooberrsummary, which(Mean <= min(Mean + SD)))
minfeatures <- colnames(training)[1:min(minerrsd)]
sfsmatrix <- training[, 1:min(minerrsd), drop = FALSE]
outlst <- list(selected_features = minfeatures,
feature_subsets_with_min_OOBerror_plus_1SD = minerrsd,
OOB_error_rate_summary = ooberrsummary,
SFS_matrix = sfsmatrix)
sink(file = paste(objTitle,".SFS.txt",sep = ""), append = FALSE) # dump the results to a file
print(outlst)
sink() # end dump
## plot
if (plot){
# check the feature number
if (nrow(ooberrsummary) == 1){
## print msg
print("Only one vaiable detected. No need to plot.")
## output to env
return(assign(paste(objTitle, "_SFS", sep = ""), outlst, envir = .GlobalEnv))
} else {
loclEnv <- environment()
# prepare plotting dataframe
if (n != "all"){
pltdfm <- head(ooberrsummary, n)
} else {
pltdfm <- ooberrsummary
}
# plotting
baseplt <- ggplot(ooberrsummary, aes(x = Features, y = Mean, group = 1), environment = loclEnv) +
geom_line() +
geom_point(size = symbolSize) +
scale_x_discrete(expand = c(0.01, 0)) +
ggtitle(Title) +
xlab(xLabel) + # the arguments for x and y labls are switched as the figure is rotated
ylab(yLabel) + # the arguments for x and y labls are switched as the figure is rotated
geom_vline(xintercept = min(minerrsd), linetype = "dashed") +
theme(panel.background = element_rect(fill = 'white', colour = 'black'),
panel.border = element_rect(colour = "black", fill = NA, size = 0.5),
plot.title = element_text(hjust = 0.5),
legend.position = "bottom",
legend.title = element_blank(),
axis.text.x = element_text(size = xTxtSize),
axis.text.y = element_text(size = yTxtSize, hjust = 0.5))
if (errorbar == "SEM"){
plt <- baseplt +
geom_errorbar(aes(ymin = Mean - SEM, ymax = Mean + SEM), width = errorbarWidth, position = position_dodge(0.9)) +
scale_y_continuous(expand = c(0, 0),
limits = c(with(ooberrsummary, min(Mean - SEM) * 0.6),
with(ooberrsummary, max(Mean + SEM) * 1.2)))
} else if (errorbar == "SD") {
plt <- baseplt +
geom_errorbar(aes(ymin = Mean - SD, ymax = Mean + SD), width = errorbarWidth, position = position_dodge(0.9)) +
scale_y_continuous(expand = c(0, 0),
limits = c(with(ooberrsummary, min(Mean - SD) * 0.6),
with(ooberrsummary, max(Mean + SD) * 1.2)))
}
grid.newpage()
# extract gtable
pltgtb <- ggplot_gtable(ggplot_build(plt))
# add the right side y axis
Aa <- which(pltgtb$layout$name == "axis-l")
pltgtb_a <- pltgtb$grobs[[Aa]]
axs <- pltgtb_a$children[[2]]
axs$widths <- rev(axs$widths)
axs$grobs <- rev(axs$grobs)
axs$grobs[[1]]$x <- axs$grobs[[1]]$x - unit(1, "npc") + unit(0.08, "cm")
Ap <- c(subset(pltgtb$layout, name == "panel", select = t:r))
pltgtb <- gtable_add_cols(pltgtb, pltgtb$widths[pltgtb$layout[Aa, ]$l], length(pltgtb$widths) - 1)
pltgtb <- gtable_add_grob(pltgtb, axs, Ap$t, length(pltgtb$widths) - 1, Ap$b)
# export the file and draw a preview
ggsave(filename = paste(objTitle,".OOB.plot.pdf", sep = ""), plot = pltgtb,
width = plotWidth, height = plotHeight, units = "mm",dpi = 600) # deparse(substitute(x)) converts object name into a character string
grid.draw(pltgtb) # preview
}
}
## output to env
return(assign(paste(objTitle, "_SFS", sep = ""), outlst, envir = .GlobalEnv))
}
phase1(objTitle = "HCvPTSD", HCvPTSD_inital_FS$matrix_initial_FS, tgtVar_HCvPTSD, errorbar = "SD",
nTree = 501, mTry = "rf_default", Title = "OOB error for HC vs PTSD")
rm(HCvPTSD_SFS)
phase1(objTitle = "HCvPTSD", HCvPTSD_inital_FS$matrix_initial_FS, tgtVar_HCvPTSD, errorbar = "SD",
nTree = 501, mTry = "rf_default", Title = "OOB error for HC vs PTSD")
HCvPTSD_SFS
setwd("~/OneDrive/knowledge_lib/Bioinformatics/[scripts]in_dev_codes/git_repos/git_RBioFS/RBioFS")
devtools::document()
devtools::document()
library(RBioFS)
?rbioIMP
require(RBioFS)
?rbioIMP
?rbioFS::rbioIMP
?rbioRF_initialFS
?get
devtools::document()
library(RBioFS)
devtools::document()
library(RBioFS)
devtools::document()
library(RBioFS)
devtools::docu
devtools::document()
library(RBioFS)
?rbioRF_initialFS
devtools
devtools::document()
library(RBioFS)
?rbioRF_SFS
devtools::document()
library(RBioFS)
devtools::document()
library(RBioFS)
devtools::document()
library(RBioFS)
?data.frame
?read.csv
devtools::document()
library(RBioFS)
substr(noquote("file.csv"), 1, nchar(file) - 4)
substr(noquote("file.csv"), 1, nchar("file.csv") - 4)
substr(noquote("file.csv"), 1, nchar("file.csv") - 4)
devtools::document()
library(RBioFS)
?nchar
nchar(file)
devtools::document()
library(RBioFS)
devtools::document()
library(RBioFS)
devtools::document()
library(RBioFS)
devtools::document()
library(RBioFS)
?write.csv
devtools::document()
library(RBioFS)
devtools::document()
library(RBioFS)
devtools::document()
library(RBioFS)
?rbioFS
require(RBioFS)
?rbioFS
devtools::document()
library(RBioFS)
?rbioFS
devtools::document()
library(RBioFS)
?rbioFS
devtools::document()
library(RBioFS)
devtools::document()
library(RBioFS)
