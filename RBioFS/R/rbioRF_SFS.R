#' @title rbioRF_SFS_plot
#'
#' @description Variable OOB error rate curve plot function for \code{rf_sfs} obejcts generated by \code{rbioRF_SFS()} or \code{rbioFS()}.
#' @param object A \code{rf_sfs} object. Make sure the object is generated with a \code{validation} section.
#' @param n Number of features to show. Takes integer numbers. Default is \code{"all"} (make sure to include quotation marks).
#' @param plot.file.title Plot file title prefix. Defatuls is \code{deparse(substitute(object))}.
#' @param plot.title Whether to display plot title on top of the plot. Default is \code{FALSE}.
#' @param plot.titleSize The font size of the plot title. Default is \code{10}.
#' @param plot.SymbolSize Symbol size. Default is \code{2}.
#' @param plot.errorbar Set the type of errorbar. Options are standard error of the mean (\code{"SEM"}, \code{"standard error"}, \code{"standard error of the mean"}), or standard deviation (\code{"SD"}, \code{"standard deviation"}), case insensitive. Default is \code{"SEM"}.
#' @param plot.errorbarWidth Set the width for errorbar. Default is \code{0.2}.
#' @param plot.fontType The type of font in the figure. Default is "sans". For all options please refer to R font table, which is avaiable on the website: \url{http://kenstoreylab.com/?page_id=2448}.
#' @param plot.xLabel x axis label. Type with quotation marks. Could be NULL. Default is \code{"Features"}.
#' @param plot.xLabelSize x axis label size. Default is \code{10}.
#' @param plot.xTickLblSize Font size of x axis ticks. Default is \code{10}.
#' @param plot.xTickItalic Set x axis tick font to italic. Default is \code{FALSE}.
#' @param plot.xTickBold Set x axis tick font to bold. Default is \code{FALSE}.
#' @param plot.xAngle The rotation angle (degrees) of the x axis marks. Default is \code{0} - horizontal.
#' @param plot.xhAlign The horizontal alignment type of the x axis marks. Options are \code{0}, \code{0.5} and \code{1}. The default value at \code{0} is especially useful when \code{xAngle = 90}.
#' @param plot.xvAlign The vertical alignment type of the x axis marks. Options are \code{0}, \code{0.5} and \code{1}. The default value at \code{0} is especially useful when \code{xAngle = 90}.
#' @param plot.rightsideY If to display the right side y-axis. Default is \code{TRUE}.
#' @param plot.yLabel y axis label. Type with quotation marks. Could be NULL. Default is \code{"OOB error rate"}.
#' @param plot.yLabelSize y axis label size. Default is \code{10}.
#' @param plot.yTickLblSize Font size of y axis ticks. Default is \code{10}.
#' @param plot.yTickItalic Set y axis tick font to italic. Default is \code{FALSE}.
#' @param plot.yTickBold Set y axis tick font to bold. Default is \code{FALSE}.
#' @param plot.Width The width of the plot (unit: mm). Default is 170. Default will fit most of the cases.
#' @param plot.Height The height of the plot (unit: mm). Default is 150. Default will fit most of the cases.
#' @param verbose Wether to display messages. Default is \code{TRUE}. This will be affect error or warning messeages.
#' @return The function also generates the pdf OOB error curve figure files to the working directory.
#' @importFrom reshape2 melt
#' @importFrom grid grid.newpage grid.draw
#' @importFrom RBioplot rightside_y
#' @importFrom scales rescale_none
#' @import pls
#' @import ggplot2
#' @examples
#' \dontrun{
#' rbioRF_SFS_plot(object = data_SFS, n = "all",plot.title = TRUE, plot.titleSize = 10,
#'                        plot.outlineCol = "black", plot.errorbar = "SEM", plot.errorbarWidth = 0.2,
#'                        plot.errorbarLblSize = 6, plot.fontType = "sans", plot.xLabel = "Features",
#'                        plot.xLabelSize = 10, plot.xTickLblSize = 10, plot.xTickItalic = FALSE,
#'                        plot.xTickBold = FALSE, plot.xAngle = 90, plot.xhAlign = 1, plot.xvAligh = 0.2, plot.rightsideY = TRUE,
#'                        plot.yLabel = "Mean Decrease in Accuracy", plot.yLabelSize = 10, plot.yTickLblSize = 10,
#'                        plot.yTickItalic = FALSE, plot.yTickBold = FALSE, plot.legendSize = 9,
#'                        plot.legendTtl = FALSE, plot.legendTtlSize = 9, plot.Width = 170,
#'                        plot.Height = 150)
#' }
#' @export
rbioRF_SFS_plot <- function(object, n = "all",
                            plot.file.title = deparse(substitute(object)),
                            plot.title = NULL, plot.titleSize = 10,
                            plot.symbolSize = 2,
                            plot.errorbar = "sem", plot.errorbarWidth = 0.2,
                            plot.fontType = "sans",
                            plot.xLabel = "Features", plot.xLabelSize = 10,
                            plot.xAngle = 0, plot.xhAlign = 0.5, plot.xvAlign = 0.5,
                            plot.xTickLblSize = 10, plot.xTickItalic = FALSE, plot.xTickBold = FALSE,
                            plot.rightsideY = TRUE,
                            plot.yLabel = "OOB error rate", plot.yLabelSize = 10, plot.yTickLblSize = 10, plot.yTickItalic = FALSE,
                            plot.yTickBold = FALSE,
                            plot.Width = 170, plot.Height = 150,
                            verbose = TRUE){
  ## check arguments
  if (class(object) != "rf_sfs") stop("object needs to be \"rf_sfs\" class generated by rbioRF_SFS() or rbioFS()")

  ## construuct plot dataframe
  pltdfm <- object$OOB_error_rate_summary
  pltdfm$Features <- as.numeric(factor(pltdfm$Features, levels = unique(pltdfm$Features)))
  if (n != "all"){
    if (n %% 1 != 0){
      cat("n is not an integer and has been converted to one.\n")
      n <- as.integer(n)
    }
    if (n > nrow(pltdfm)){
      cat("n > total feature count. proceed without subsetting. \n")
    } else {
      pltdfm <- head(pltdfm, n)
    }
  }

  ## plot
  if (plot.xTickLblSize == 0) cat("Due to plot.xTickLblSize = 0, x-axis ticks are hidden for the OOB error rate curve plot.\n")

  # error bar
  if (tolower(plot.errorbar) %in% c("sem", "standard error", "standard error of the mean")){  # error bar
    err <- pltdfm$SEM
  } else if (tolower(plot.errorbar) %in% c("sd", "standard deviation")){
    err <- pltdfm$SD
  }

  # use tryCatch in the case of non of the coef are > or < 0.
  ymax <- (max(pltdfm$Mean + err) * 1.05)
  ymin <- (min(pltdfm$Mean - err) * 1.15)

  if (verbose) cat(paste("OOB plot being saved to file: ", plot.file.title,".rffs.sfs.plot.pdf...", sep = ""))  # initial message
  loclEnv <- environment()
  baseplt <- ggplot(pltdfm, aes(x = Features, y = Mean), environment = loclEnv) +
    geom_line() +
    geom_point(size = plot.symbolSize) +
    geom_errorbar(aes(ymin = Mean - err, ymax = Mean + err),
                  position = position_dodge(0.9), color = "black", width = plot.errorbarWidth) +
    scale_x_continuous(expand = c(0.01, 0.01)) +
    scale_y_continuous(expand = c(0, 0), limits = c(ymin, ymax),
                       oob = rescale_none) +
    ggtitle(plot.title) +
    xlab(plot.xLabel) +
    ylab(plot.yLabel) +
    geom_vline(xintercept = min(object$feature_subsets_with_min_OOBerror_plus_1SD), linetype = "dashed", colour = "red") +
    geom_hline(yintercept = 0) +
    theme(panel.background = element_rect(fill = 'white', colour = 'black'),
          panel.border = element_rect(colour = "black", fill = NA, size = 0.5),
          plot.title = element_text(face = "bold", size = plot.titleSize, family = plot.fontType),
          axis.title.x = element_text(face = "bold", size = plot.xLabelSize, family = plot.fontType),
          axis.title.y = element_text(face = "bold", size = plot.yLabelSize, family = plot.fontType),
          axis.text.x = element_text(size = plot.xTickLblSize, family = plot.fontType, angle = plot.xAngle,
                                     hjust = plot.xhAlign, vjust = plot.xvAlign),
          axis.text.y = element_text(size = plot.yTickLblSize, family = plot.fontType, hjust = 0.5),
          axis.ticks.x = if(plot.xTickLblSize == 0) element_blank())

  if (plot.xTickItalic & plot.xTickBold){
    baseplt <- baseplt +
      theme(axis.text.x = element_text(face = "bold.italic"))
  } else if (plot.xTickItalic & !plot.xTickBold){
    baseplt <- baseplt +
      theme(axis.text.x = element_text(face = "italic"))
  } else if (plot.xTickBold & !plot.xTickItalic){
    baseplt <- baseplt +
      theme(axis.text.x = element_text(face = "bold"))
  }

  if (plot.yTickItalic & plot.yTickBold){
    baseplt <- baseplt +
      theme(axis.text.y  = element_text(face = "bold.italic"))
  } else if (plot.yTickItalic & !plot.yTickBold){
    baseplt <- baseplt +
      theme(axis.text.y = element_text(face = "italic"))
  } else if (plot.yTickBold & !plot.yTickItalic){
    baseplt <- baseplt +
      theme(axis.text.y = element_text(face = "bold"))
  }

  ## add the right-side y axis
  grid.newpage()
  pltgtb <- RBioplot::rightside_y(baseplt)

  # export the file and draw a preview
  ggsave(filename = paste(plot.file.title,".rffs.sfs.plot.pdf", sep = ""), plot = pltgtb,
         width = plot.Width, height = plot.Height, units = "mm",dpi = 600)
  grid.draw(pltgtb) # preview
  if (verbose) cat("Done!\n")
}


#' @title rbioRF_SFS
#'
#' @description Recursive nested random froest variable importance (vi) and OOB error rate computation in a sequential forward selection (SFS) manner.
#' @param objTitle The title for the output data frame. Default is \code{"x_vs_tgt"}
#' @param x Input dataframe or matrix. Make sure to arrange the data with features as column names.
#' @param targetVar The target variable for random forest feature selection. This is a factor object.
#' @param nTimes Number of random forest vi computation runs. Default is \code{50} times.
#' @param nTree Number of trees generated for each random forest run. Default is \code{1001} trees.
#' @param mTry Number of randomly selected featurs for constructing trees. When \code{"recur_default"}, it'll be based on \code{p / 3}; when \code{"rf_default"}, it will use the default setting in \code{randomForest} package. Default is \code{"recur_default"}.
#' @param multicore If to use parallel computing. Default is \code{TRUE}.
#' @param plot If to plot a bargraph to visualize vi and the ranking. Default is \code{TRUE}
#' @param n Number of features to show. Takes integer numbers. Default is \code{"all"} (make sure to include quotation marks).
#' @param ... Additional arguments passed to the plot function \code{\link{rbioRF_SFS_plot}}.
#' @return Outputs a \code{rf_sfs} object with  OOB error rate summary, and a joint-point curve in \code{csv} format.
#' @details Make sure to arrange data (dfm) with feature (e.g., gene) as variables (i.e., columns), and rownames as sample names.
#' @import ggplot2
#' @import foreach
#' @importFrom grid grid.newpage grid.draw
#' @importFrom gtable gtable_add_cols gtable_add_grob
#' @importFrom randomForest randomForest importance
#' @importFrom parallel detectCores makeCluster stopCluster
#' @importFrom doParallel registerDoParallel
#' @importFrom RBioplot rightside_y
#' @examples
#' \dontrun{
#' rbioRF_SFS(training_HCvTC, tgtVar_HCvTC, multicore = TRUE)
#' }
#' @export
rbioRF_SFS <- function(objTitle = "x_vs_tgt",
                       x, targetVar, nTimes = 50, nTree = 1001, mTry = "recur_default",
                       multicore = TRUE,
                       plot = TRUE, n = "all", ...){
  ## prepare the dataframe
  training <- data.frame(x, check.names = FALSE)

  ### pepare the target variable
  tgt <- factor(as.character(targetVar), levels = unique(targetVar))

  ### prepare draw size. this uses down-sampling if the samples are unbalanced
  nlvl <- length(levels(tgt))
  size <- min(as.vector(table(tgt))) # down-sampling
  drawSize <- rep(size, nlvl)

  ## prepare blank tree OOB error matrics
  singleerrmtx <- matrix(nrow = 1, ncol = nTimes) # for the recursive OOB error rates from a single tree
  ooberrmtx <- matrix(nrow = ncol(training), ncol = nTimes) # for the recursive OOB error rates from all trees.

  if (!multicore){

    ## signle core computing: recursive structure
    tmpFunc <- function(n, m, tmperrmtx, tmpTraining, tmpTgt,
                        tmpTree, tmpTry, tmpSize){

      if (n == 0){
        return(tmperrmtx)

      } else {
        if (tmpTry == "recur_default"){

          if (ncol(tmpTraining) < 4){
            rf <- randomForest(x = tmpTraining, y = tmpTgt, ntree = tmpTree, importance = TRUE,
                               proximity = TRUE, drawSize = tmpSize)
          } else {
            rf <- randomForest(x = tmpTraining, y = tmpTgt, ntree = tmpTree, mtry = max(floor(ncol(tmpTraining) / 3), 2),
                               importance = TRUE,
                               proximity = TRUE, drawSize = tmpSize)
          }

        } else if (tmpTry == "rf_default"){
          rf <- randomForest(x = tmpTraining, y = tmpTgt, ntree = tmpTree,
                             importance = TRUE,
                             proximity = TRUE, drawSize = tmpSize)
        } else {
          stop("Please select a proper mtry setting")
        }

        tmperrmtx[, m] <- tail(rf$err.rate[, 1], n = 1) # fill the OOB error rate
        tmpFunc(n - 1, m + 1, tmperrmtx, tmpTraining, tmpTgt,
                tmpTree, tmpTry, tmpSize)
      }
    }

    tmpFunc2 <- function(i, j, tmp2mtx, ...){
      if (i == 0){
        rownames(tmp2mtx) <- seq(j - 1)
        colnames(tmp2mtx) <- c(paste("OOB_error_tree_rep", seq(nTimes), sep = "_"))

        return(tmp2mtx)
      } else {
        tmp2mtx[j, ] <- tmpFunc(n = nTimes, m = 1, tmperrmtx = singleerrmtx,
                                tmpTraining = training[, 1:j, drop = FALSE], tmpTgt = tgt, tmpTree = nTree, tmpTry = mTry,
                                tmpSize = drawSize)
        tmpFunc2(i - 1, j + 1, tmp2mtx, ...)
      }
    }

    mtxforfunc2 <- ooberrmtx

    ooberrmtx <- tmpFunc2(i = ncol(training), j = 1, tmp2mtx = mtxforfunc2) # j is the tree index

  } else { ## parallel computing
    # set up cpu cluster
    n_cores <- detectCores() - 1
    cl <- makeCluster(n_cores)
    registerDoParallel(cl)
    on.exit(stopCluster(cl)) # close connect when exiting the function

    # recursive RF using par-apply functions
    tmpfunc3 <- function(j){
      if (mTry == "recur_default"){
        if (j < 4){
          rf <- randomForest::randomForest(x = training[, 1:j, drop = FALSE], y = tgt, ntree = nTree, importance = TRUE,
                                           proximity = TRUE, drawSize = drawSize)

        } else {
          rf <- randomForest::randomForest(x = training[, 1:j, drop = FALSE], y = tgt, ntree = nTree, mtry = max(floor(ncol(training[1:j]) / 3), 2),
                                           importance = TRUE,
                                           proximity = TRUE, drawSize = drawSize)
        }
      } else if (mTry == "rf_default"){
        rf <- randomForest::randomForest(x = training[, 1:j, drop = FALSE], y = tgt, ntree = nTree, importance = TRUE,
                                         proximity = TRUE, drawSize = drawSize)
      } else {
        stop("Please select a proper mtry setting")
      }

      tmperrmtx <- tail(rf$err.rate[, 1], n = 1) # compute the OOB error rate
      lst <- list(tmperrmtx = tmperrmtx)
    }

    l <- foreach(i = 1:ncol(training), .packages = c("foreach")) %dopar% {
      tmp <- foreach(j = 1:nTimes) %dopar% tmpfunc3(i)
      errmtx <- foreach(i = 1:nTimes, .combine = cbind) %dopar% tmp[[i]]$tmperrmtx
      lst <- list(errmtx = errmtx)
    }
    ooberrmtx <- foreach(j = 1:ncol(training), .combine = rbind) %dopar% l[[j]]$errmtx

    rownames(ooberrmtx) <- seq(ncol(training))
    colnames(ooberrmtx) <- c(paste("OOB_error_tree_rep", seq(nTimes), sep = "_"))

  }

  ## perpare the summary dataframe for OOB error rates
  ooberrnames <- rownames(ooberrmtx)
  ooberrmean <- rowMeans(ooberrmtx)
  ooberrSD <- apply(ooberrmtx, 1, sd)
  ooberrSEM <- sapply(ooberrSD, function(x)x / sqrt(ncol(ooberrmtx)))
  ooberrsummary <- data.frame(Features = ooberrnames, Mean = ooberrmean, SD = ooberrSD,
                              SEM = ooberrSEM, stringsAsFactors = FALSE)
  ooberrsummary$Features <- factor(ooberrsummary$Features, levels = unique(ooberrsummary$Features))

  ## output
  mean_min_idx <- which.min(ooberrsummary$Mean)  # index for the minimum mean oob feature group
  sd_min <- ooberrsummary$SD[mean_min_idx]  # oob SD for the feature group above
  minerrsd <- with(ooberrsummary, which(Mean <= (Mean[mean_min_idx] + sd_min)))  # 1sd minimum selection

  minfeatures <- colnames(training)[1:min(minerrsd)]
  sfsmatrix <- training[, 1:min(minerrsd), drop = FALSE]

  outlst <- list(selected_features = minfeatures,
                 feature_subsets_with_min_OOBerror_plus_1SD = minerrsd,
                 OOB_error_rate_summary = ooberrsummary,
                 SFS_training_data_matrix = sfsmatrix)

  sink(file = paste(objTitle,".SFS.txt",sep = ""), append = FALSE) # dump the results to a file
  print(outlst)
  sink() # end dump
  class(outlst) <- "rf_sfs"

  ## plot
  if (plot){
    # check the feature number
    if (nrow(ooberrsummary) == 1){
      ## print msg
      print("Only single feature subset detected. No need to plot.")
      ## output to env
      return(assign(paste(objTitle, "_SFS", sep = ""), outlst, envir = .GlobalEnv))
    } else {
      rbioRF_SFS_plot(object = outlst, n = n, plot.file.title = objTitle, ...)
    }
  }

  ## output to env
  return(assign(paste(objTitle, "_SFS", sep = ""), outlst, envir = .GlobalEnv))
}
