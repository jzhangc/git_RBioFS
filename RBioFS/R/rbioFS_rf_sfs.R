#' @title rbioFS_rf_SFS_plot
#'
#' @description Variable error curve plot function for \code{rf_sfs} obejcts generated by \code{rbioFS_rf_SFS()} or \code{rbioFS()}.
#' @param object A \code{rf_sfs} object. Make sure the object is generated with a \code{validation} section.
#' @param n Number of features to show. Takes integer numbers. Default is \code{"all"} (make sure to include quotation marks).
#' @param plot.file.title Plot file title prefix. Defatuls is \code{deparse(substitute(object))}.
#' @param plot.title Whether to display plot title on top of the plot. Default is \code{FALSE}.
#' @param plot.titleSize The font size of the plot title. Default is \code{10}.
#' @param plot.SymbolSize Symbol size. Default is \code{2}.
#' @param plot.errorbar Set the type of errorbar. Options are standard error of the mean (\code{"sem"}) or standard deviation (\code{"sd"}, case insensitive. Default is \code{"sem"}.
#' @param plot.errorbarWidth Set the width for errorbar. Default is \code{0.2}.
#' @param plot.fontType The type of font in the figure. Default is "sans". For all options please refer to R font table, which is avaiable on the website: \url{http://kenstoreylab.com/?page_id=2448}.
#' @param plot.xLabel x axis label. Type with quotation marks. Could be NULL. Default is \code{"Features"}.
#' @param plot.xLabelSize x axis label size. Default is \code{10}.
#' @param plot.xTickLblSize Font size of x axis ticks. Default is \code{10}.
#' @param plot.xTickItalic Set x axis tick font to italic. Default is \code{FALSE}.
#' @param plot.xTickBold Set x axis tick font to bold. Default is \code{FALSE}.
#' @param plot.xAngle The rotation angle (degrees) of the x axis marks. Default is \code{0} - horizontal.
#' @param plot.xhAlign The horizontal alignment type of the x axis marks. Options are \code{0}, \code{0.5} and \code{1}. The default value at \code{0} is especially useful when \code{xAngle = 90}.
#' @param plot.xvAlign The vertical alignment type of the x axis marks. Options are \code{0}, \code{0.5} and \code{1}. The default value at \code{0} is especially useful when \code{xAngle = 90}.
#' @param plot.rightsideY If to display the right side y-axis. Default is \code{TRUE}.
#' @param plot.yLabel y axis label. Type with quotation marks. Could be NULL. Default is \code{"OOB error rate"}.
#' @param plot.yLabelSize y axis label size. Default is \code{10}.
#' @param plot.yTickLblSize Font size of y axis ticks. Default is \code{10}.
#' @param plot.yTickItalic Set y axis tick font to italic. Default is \code{FALSE}.
#' @param plot.yTickBold Set y axis tick font to bold. Default is \code{FALSE}.
#' @param plot.Width The width of the plot (unit: mm). Default is 170. Default will fit most of the cases.
#' @param plot.Height The height of the plot (unit: mm). Default is 150. Default will fit most of the cases.
#' @param verbose Wether to display messages. Default is \code{TRUE}. This will not affect error or warning messeages.
#' @return The function also generates the pdf error curve figure files to the working directory.
#' @importFrom reshape2 melt
#' @importFrom grid grid.newpage grid.draw
#' @importFrom RBioplot rightside_y
#' @importFrom scales rescale_none
#' @import pls
#' @import ggplot2
#' @examples
#' \dontrun{
#' rbioFS_rf_SFS_plot(object = data_SFS, n = "all",plot.title = TRUE, plot.titleSize = 10,
#'                        plot.outlineCol = "black", plot.errorbar = "sem", plot.errorbarWidth = 0.2,
#'                        plot.errorbarLblSize = 6, plot.fontType = "sans", plot.xLabel = "Features",
#'                        plot.xLabelSize = 10, plot.xTickLblSize = 10, plot.xTickItalic = FALSE,
#'                        plot.xTickBold = FALSE, plot.xAngle = 90, plot.xhAlign = 1, plot.xvAligh = 0.2, plot.rightsideY = TRUE,
#'                        plot.yLabel = "Mean Decrease in Accuracy", plot.yLabelSize = 10, plot.yTickLblSize = 10,
#'                        plot.yTickItalic = FALSE, plot.yTickBold = FALSE, plot.legendSize = 9,
#'                        plot.legendTtl = FALSE, plot.legendTtlSize = 9, plot.Width = 170,
#'                        plot.Height = 150)
#' }
#' @export
rbioFS_rf_SFS_plot <- function(object, n = "all",
                            plot.file.title = deparse(substitute(object)),
                            plot.title = NULL, plot.titleSize = 10,
                            plot.symbolSize = 2,
                            plot.errorbar = c("sem", "sd"),
                            plot.errorbarWidth = 0.2,
                            plot.fontType = "sans",
                            plot.xLabel = "Features", plot.xLabelSize = 10,
                            plot.xAngle = 0, plot.xhAlign = 0.5, plot.xvAlign = 0.5,
                            plot.xTickLblSize = 10, plot.xTickItalic = FALSE, plot.xTickBold = FALSE,
                            plot.rightsideY = TRUE,
                            plot.yLabel = "OOB error rate", plot.yLabelSize = 10, plot.yTickLblSize = 10, plot.yTickItalic = FALSE,
                            plot.yTickBold = FALSE,
                            plot.Width = 170, plot.Height = 150,
                            verbose = TRUE){
  ## check arguments
  if (any(class(object) != "rf_sfs")) stop("object needs to be \"rf_sfs\" class generated by rbioFS_rf_SFS() or rbioFS()")
  plot.errorbar <- match.arg(tolower(plot.errorbar), c("sem", "sd"))

  ## construuct plot dataframe
  pltdfm <- object$error_summary
  pltdfm$Features <- as.numeric(factor(pltdfm$Features, levels = unique(pltdfm$Features)))
  if (n != "all"){
    if (n %% 1 != 0){
      cat("n is not an integer and has been converted to one.\n")
      n <- as.integer(n)
    }
    if (n > nrow(pltdfm)){
      cat("n > total feature count. proceed without subsetting. \n")
    } else {
      pltdfm <- head(pltdfm, n)
    }
  }

  ## plot
  if (plot.xTickLblSize == 0) cat("Due to plot.xTickLblSize = 0, x-axis ticks are hidden for the error curve plot.\n")

  # error bar
  if (tolower(plot.errorbar) %in% c("sem")){  # error bar
    err <- pltdfm$SEM
  } else if (tolower(plot.errorbar) %in% c("sd")){
    err <- pltdfm$SD
  }

  # use tryCatch in the case of non of the coef are > or < 0.
  ymax <- (max(pltdfm$Mean + err) * 1.05)
  ymin <- (min(pltdfm$Mean - err) * 0.75)

  if (verbose) cat(paste("OOB plot being saved to file: ", plot.file.title,".rffs.sfs.plot.pdf...", sep = ""))  # initial message
  loclEnv <- environment()
  baseplt <- ggplot(pltdfm, aes(x = Features, y = Mean), environment = loclEnv) +
    geom_line() +
    geom_point(size = plot.symbolSize) +
    geom_errorbar(aes(ymin = Mean - err, ymax = Mean + err),
                  position = position_dodge(0.9), color = "black", width = plot.errorbarWidth) +
    scale_x_continuous(expand = c(0.05, 0.05)) +
    scale_y_continuous(expand = c(0, 0), limits = c(ymin, ymax),
                       oob = rescale_none) +
    ggtitle(plot.title) +
    xlab(plot.xLabel) +
    ylab(plot.yLabel) +
    geom_vline(xintercept = min(object$feature_subsets_with_min_OOBerror_plus_1SD), linetype = "dashed", colour = "red") +
    geom_hline(yintercept = 0) +
    theme(panel.background = element_rect(fill = 'white', colour = 'black'),
          panel.border = element_rect(colour = "black", fill = NA, size = 0.5),
          plot.title = element_text(face = "bold", size = plot.titleSize, family = plot.fontType),
          axis.title.x = element_text(face = "bold", size = plot.xLabelSize, family = plot.fontType),
          axis.title.y = element_text(face = "bold", size = plot.yLabelSize, family = plot.fontType),
          axis.text.x = element_text(size = plot.xTickLblSize, family = plot.fontType, angle = plot.xAngle,
                                     hjust = plot.xhAlign, vjust = plot.xvAlign),
          axis.text.y = element_text(size = plot.yTickLblSize, family = plot.fontType, hjust = 0.5),
          axis.ticks.x = if(plot.xTickLblSize == 0) element_blank())

  if (plot.xTickItalic & plot.xTickBold){
    baseplt <- baseplt +
      theme(axis.text.x = element_text(face = "bold.italic"))
  } else if (plot.xTickItalic & !plot.xTickBold){
    baseplt <- baseplt +
      theme(axis.text.x = element_text(face = "italic"))
  } else if (plot.xTickBold & !plot.xTickItalic){
    baseplt <- baseplt +
      theme(axis.text.x = element_text(face = "bold"))
  }

  if (plot.yTickItalic & plot.yTickBold){
    baseplt <- baseplt +
      theme(axis.text.y  = element_text(face = "bold.italic"))
  } else if (plot.yTickItalic & !plot.yTickBold){
    baseplt <- baseplt +
      theme(axis.text.y = element_text(face = "italic"))
  } else if (plot.yTickBold & !plot.yTickItalic){
    baseplt <- baseplt +
      theme(axis.text.y = element_text(face = "bold"))
  }

  ## add the right-side y axis
  # grid.newpage()
  pltgtb <- RBioplot::rightside_y(baseplt)

  # export the file and draw a preview
  ggsave(filename = paste(plot.file.title,".rffs.sfs.plot.pdf", sep = ""), plot = pltgtb,
         width = plot.Width, height = plot.Height, units = "mm",dpi = 600)
  grid.draw(pltgtb) # preview
  if (verbose) cat("Done!\n")
}


#' @title rbioFS_rf_SFS
#'
#' @description Recursive nested random froest variable importance (vi) and error computation in a sequential forward selection (SFS) manner.
#' @param objTitle The title for the output data frame. Default is \code{"x_vs_tgt"}
#' @param x Input dataframe or matrix. Make sure to arrange the data with features as column names. Note this excludes the label column.
#' @param y The target (outcome) variable for random forest feature selection.
#' @param nTimes Number of random forest vi computation runs. Default is \code{50} times.
#' @param nTree Number of trees generated for each random forest run. Default is \code{1001} trees.
#' @param parallelComputing Wether to use parallel computing or not. Default is \code{TRUE}.
#' @param n_cores Only set when \code{parallelComputing = TRUE}, the number of CPU cores to use. Default is \code{detectCores() - 1}, or the total number cores minus one.
#' @param clusterType Only set when \code{parallelComputing = TRUE}, the type for parallel cluster. Options are \code{"PSOCK"} (all operating systems) and \code{"FORK"} (macOS and Unix-like system only). Default is \code{"PSOCK"}.
#' @param plot If to plot a bargraph to visualize vi and the ranking. Default is \code{TRUE}
#' @param n Number of features to show. Takes integer numbers. Default is \code{"all"} (make sure to include quotation marks).
#' @param ... Additional arguments passed to the plot function \code{\link{rbioFS_rf_SFS_plot}}.
#' @return Outputs a \code{rf_sfs} object with  OOB error rate summary, and a joint-point curve in \code{csv} format.
#'         When \code{plot = TRUE}, a error curve is also generated and exported as a \code{pdf} file.
#'         Detailed results are also exported into a \code{csv} file and a \code{txt} file to the working directory.
#' @details Make sure to arrange data (dfm) with feature (e.g., gene) as variables (i.e., columns), and rownames as sample names.
#' @import ggplot2
#' @import foreach
#' @importFrom grid grid.newpage grid.draw
#' @importFrom gtable gtable_add_cols gtable_add_grob
#' @importFrom randomForest randomForest importance
#' @importFrom parallel detectCores makeCluster stopCluster
#' @importFrom doParallel registerDoParallel
#' @importFrom RBioplot rightside_y
#' @examples
#' \dontrun{
#' rbioFS_rf_SFS(training_HCvTC, tgtVar_HCvTC, parallelComputing = TRUE)
#' }
#' @export
rbioFS_rf_SFS <- function(objTitle = "x_vs_tgt",
                          x, y, nTimes = 50, nTree = 1001,
                          parallelComputing = TRUE, n_cores = parallel::detectCores() - 1, clusterType = c("PSOCK", "FORK"),
                          plot = TRUE, n = "all", ...){
  #### run time initiation
  start_time <- Sys.time()

  #### check arguments
  if (parallelComputing){
    clusterType <- match.arg(clusterType, c("PSOCK", "FORK"))
  }

  #### prepare the dataframe
  training <- data.frame(x, check.names = FALSE)
  tgt <- y

  # ### pepare the target variable
  # tgt <- factor(as.character(y), levels = unique(y))
  #
  # ### prepare draw size. this uses down-sampling if the samples are unbalanced
  # nlvl <- length(levels(tgt))
  # size <- min(as.vector(table(tgt))) # down-sampling
  # drawSize <- rep(size, nlvl)

  ## prepare blank tree OOB error matrics
  singleerrmtx <- matrix(nrow = 1, ncol = nTimes) # for the recursive OOB error rates from a single tree
  ooberrmtx <- matrix(nrow = ncol(training), ncol = nTimes) # for the recursive OOB error rates from all trees.

  # recursive RF using par-apply functions
  rf_modelling_func <- function(j){
    rf <- randomForest::randomForest(x = training[, 1:j, drop = FALSE], y = tgt, ntree = nTree,
                                     importance = TRUE, proximity = TRUE)
    if (is.factor(tgt)) {
      tmperrmtx <- tail(rf$err.rate[, 1], n = 1) # compute the OOB error rate
    } else {
      tmperrmtx <- tail(rf$mse, n = 1) # compute the MSE
    }
    lst <- list(tmperrmtx = tmperrmtx)
  }

  if (!parallelComputing){
    l <- foreach(i = 1:ncol(training), .packages = c("foreach")) %do% {
      tmp <- foreach(j = 1:nTimes) %do% rf_modelling_func(i)
      errmtx <- foreach(i = 1:nTimes, .combine = cbind) %do% tmp[[i]]$tmperrmtx
      lst <- list(errmtx = errmtx)
    }
    ooberrmtx <- foreach(j = 1:ncol(training), .combine = rbind) %do% l[[j]]$errmtx

  } else { ## parallel computing
    # set up cpu cluster
    n_cores <- n_cores
    cl <- makeCluster(n_cores, type = clusterType)
    registerDoParallel(cl)
    on.exit(stopCluster(cl)) # close connect when exiting the function

    l <- foreach(i = 1:ncol(training), .packages = c("foreach")) %dopar% {
      tmp <- foreach(j = 1:nTimes) %do% rf_modelling_func(i)
      errmtx <- foreach(i = 1:nTimes, .combine = cbind) %do% tmp[[i]]$tmperrmtx
      lst <- list(errmtx = errmtx)
    }
    ooberrmtx <- foreach(j = 1:ncol(training), .combine = rbind) %dopar% l[[j]]$errmtx

  }
  rownames(ooberrmtx) <- seq(ncol(training))
  colnames(ooberrmtx) <- c(paste("OOB_error_tree_rep", seq(nTimes), sep = "_"))

  ## perpare the summary dataframe for OOB error rates
  ooberrnames <- rownames(ooberrmtx)
  ooberrmean <- rowMeans(ooberrmtx)
  ooberrSD <- apply(ooberrmtx, 1, sd)
  ooberrSEM <- sapply(ooberrSD, function(x)x / sqrt(ncol(ooberrmtx)))
  ooberrsummary <- data.frame(Features = ooberrnames, Mean = ooberrmean, SD = ooberrSD,
                              SEM = ooberrSEM, stringsAsFactors = FALSE)
  ooberrsummary$Features <- factor(ooberrsummary$Features, levels = unique(ooberrsummary$Features))

  ## output
  mean_min_idx <- which.min(ooberrsummary$Mean)  # index for the minimum mean oob feature group
  sd_min <- ooberrsummary$SD[mean_min_idx]  # oob SD for the feature group above
  minerrsd <- with(ooberrsummary, which(Mean <= (Mean[mean_min_idx] + sd_min)))  # 1sd minimum selection

  minfeatures <- colnames(training)[1:min(minerrsd)]
  sfsmatrix <- training[, 1:min(minerrsd), drop = FALSE]

  #### export results
  ## run time
  runtime <- Sys.time() - start_time

  if (is.factor(y)){
    err_type <- "OOB"
  } else {
    err_type <- "MSE"
  }

  ## object
  outlst <- list(selected_features = minfeatures,
                 feature_subsets_with_min_OOBerror_plus_1SD = minerrsd,
                 error_evaluation_type = err_type,
                 ntree = nTree,
                 rf_iteration = nTimes,
                 error_summary = ooberrsummary,
                 SFS_training_data_matrix = sfsmatrix,
                 SFS_run_time = paste0(signif(runtime[[1]], 4), " ", attributes(runtime)[2]))
  class(outlst) <- "rf_sfs"

  ## export to files
  write.csv(file = paste0(objTitle, ".SFS.error_table.csv"), outlst$error_summary , row.names = FALSE)

  sink(file = paste(objTitle,".SFS.txt",sep = ""), append = FALSE) # dump the results to a file
  print(outlst[!names(outlst) %in% c("error_summary", "SFS_training_data_matrix")])
  sink() # end dump

  ## plot
  if (plot){
    # check the feature number
    if (nrow(ooberrsummary) == 1){
      ## print msg
      print("Only single feature subset detected. No need to plot.")
      ## output to env
      return(assign(paste(objTitle, "_SFS", sep = ""), outlst, envir = .GlobalEnv))
    } else {
      rbioFS_rf_SFS_plot(object = outlst, n = n, plot.file.title = objTitle, ...)
    }
  }

  ## output to env
  return(assign(paste(objTitle, "_SFS", sep = ""), outlst, envir = .GlobalEnv))
}

#' @export
print.rf_sfs <- function(x, ...){
  cat("Feature selected from sequential forward selection:\n")
  print(x$selected_features)
  cat("\n")
  if (length(x$selected_features) == 1) cat("Note: SFS might be overfitted as only one feature is selected.")
  cat("\n")
  cat("SFS run time: ")
  print(x$SFS_run_time)
}
