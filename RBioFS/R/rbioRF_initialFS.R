#' @title rbioFS_rf_initialFS_plot
#'
#' @description Variable importance (VI) plot function for \code{rf_ifs} objects generated by \code{rbioFS_rf_initialFS()} or \code{rbioFS()}.
#' @param object A \code{rf_ifs} object. Make sure the object is generated with a \code{validation} section.
#' @param n Number of features to plot. Options are \code{"all"} or an integer. Defatult is \code{"all"}.
#' @param plot.file.title Plot file title prefix. Defaults is \code{deparse(substitute(object))}.
#' @param plot.title Whether to display plot title on top of the plot. Default is \code{FALSE}.
#' @param plot.fs.line Whether to display the vi line at the feature selection threshold. Default is \code{TRUE}.
#' @param plot.titleSize The font size of the plot title. Default is \code{10}.
#' @param plot.outlineCol The outline colour for the bar gars. Default is \code{"black"}.
#' @param plot.errorbar Set the type of errorbar. Options are standard error of the mean (\code{"sem"}) or standard deviation (\code{"sd"}, case insensitive. Default is \code{"sem"}.
#' @param plot.errorbarWidth Set the width for errorbar. Default is \code{0.2}.
#' @param plot.fontType The type of font in the figure. Default is "sans". For all options please refer to R font table, which is available on the website: \url{http://kenstoreylab.com/?page_id=2448}.
#' @param plot.xLabel x axis label. Type with quotation marks. Could be NULL. Default is \code{"Features"}.
#' @param plot.xLabelSize x axis label size. Default is \code{10}.
#' @param plot.xTickLblSize Font size of x axis ticks. Default is \code{10}.
#' @param plot.xTickItalic Set x axis tick font to italic. Default is \code{FALSE}.
#' @param plot.xTickBold Set x axis tick font to bold. Default is \code{FALSE}.
#' @param plot.xAngle The rotation angle (degrees) of the x axis marks. Default is \code{90} - vertical.
#' @param plot.xhAlign The horizontal alignment type of the x axis marks. Options are \code{0}, \code{0.5} and \code{1}. The default value at \code{0} is especially useful when \code{xAngle = 90}.
#' @param plot.xvAlign The vertical alignment type of the x axis marks. Options are \code{0}, \code{0.5} and \code{1}. The default value at \code{0} is especially useful when \code{xAngle = 90}.
#' @param plot.rightsideY If to display the right side y-axis. Default is \code{TRUE}.
#' @param plot.yLabel y axis label. Type with quotation marks. Could be NULL. Default is \code{"Mean Decrease in Accuracy"}.
#' @param plot.yLabelSize y axis label size. Default is \code{10}.
#' @param plot.yTickLblSize Font size of y axis ticks. Default is \code{10}.
#' @param plot.yTickItalic Set y axis tick font to italic. Default is \code{FALSE}.
#' @param plot.yTickBold Set y axis tick font to bold. Default is \code{FALSE}.
#' @param plot.Width The width of the plot (unit: mm). Default is 170. Default will fit most of the cases.
#' @param plot.Height The height of the plot (unit: mm). Default is 150. Default will fit most of the cases.
#' @param verbose Whether to display messages. Default is \code{TRUE}. This will not affect error or warning messages.
#' @return The function also generates the pdf VI boxplot figure files to the working directory.
#' @importFrom reshape2 melt
#' @importFrom grid grid.newpage grid.draw
#' @importFrom RBioplot rightside_y
#' @importFrom scales rescale_none
#' @import pls
#' @import ggplot2
#' @examples
#' \dontrun{
#' rbioFS_rf_initialFS_plot(object = data_initial_FS, n = "all",plot.title = TRUE, plot.titleSize = 10,
#'                        plot.outlineCol = "black", plot.errorbar = "sem", plot.errorbarWidth = 0.2,
#'                        plot.errorbarLblSize = 6, plot.fontType = "sans", plot.xLabel = "Features",
#'                        plot.xLabelSize = 10, plot.xTickLblSize = 10, plot.xTickItalic = FALSE,
#'                        plot.xTickBold = FALSE, plot.xAngle = 90, plot.xhAlign = 1, plot.xvAligh = 0.2, plot.rightsideY = TRUE,
#'                        plot.yLabel = "Mean Decrease in Accuracy", plot.yLabelSize = 10, plot.yTickLblSize = 10,
#'                        plot.yTickItalic = FALSE, plot.yTickBold = FALSE, plot.legendSize = 9,
#'                        plot.legendTtl = FALSE, plot.legendTtlSize = 9, plot.Width = 170,
#'                        plot.Height = 150)
#' }
#' @export
rbioFS_rf_initialFS_plot <- function(object, n = "all",
                                     plot.file.title = deparse(substitute(object)),
                                     plot.title = NULL, plot.fs.line = TRUE,
                                     plot.titleSize = 10,
                                     plot.errorbar = c("sem", "sd"), plot.errorbarWidth = 0.2, plot.outlineCol = "black",
                                     plot.fontType = "sans",
                                     plot.xLabel = "Features", plot.xLabelSize = 10,
                                     plot.xAngle = 90, plot.xhAlign = 0.95, plot.xvAlign = 0.5,
                                     plot.xTickLblSize = 10, plot.xTickItalic = FALSE, plot.xTickBold = FALSE,
                                     plot.rightsideY = TRUE,
                                     plot.yLabel = "Feature Importance", plot.yLabelSize = 10, plot.yTickLblSize = 10, plot.yTickItalic = FALSE,
                                     plot.yTickBold = FALSE,
                                     plot.Width = 170, plot.Height = 150,
                                     verbose = TRUE){
  ## check arguments
  if (any(class(object) != "rf_ifs")) stop("object needs to be \"rf_ifs\" class generated by rbioFS_rf_initialFS() or rbioFS()")
  if (is.null(object$vi_at_threshold) & plot.fs.line){
    cat("No vi_at_threshold item detected in the input oject, plot.fs.line set to FALSE. \n")
    plot.fs.line <- FALSE
  }

  plot.errorbar <- match.arg(tolower(plot.errorbar), c("sem", "sd"))

  ## construuct plot dataframe
  if (any(names(object) %in% "recur_vi_summary")){
    pltdfm <- object$recur_vi_summary
  } else {
    pltdfm <- object$vi_summary
  }

  pltdfm$Target <- factor(pltdfm$Target, unique(pltdfm$Target))
  if (n != "all"){
    if (n %% 1 != 0){
      cat("n is not an integer and has been converted to one.\n")
      n <- as.integer(n)
    }
    if (n > nrow(pltdfm)){
      cat("n > total feature count. proceed without subsetting. \n")
    } else {
      pltdfm <- head(pltdfm, n)
    }
  }

  ## plot
  if (plot.xTickLblSize == 0) cat("Due to plot.xTickLblSize = 0, x-axis ticks are hidden for the VI boxplot.\n")

  # error bar
  if (tolower(plot.errorbar) %in% c("sem")){  # error bar
    err <- pltdfm$SEM
  } else if (tolower(plot.errorbar) %in% c("sd")){
    err <- pltdfm$SD
  }

  # use tryCatch in the case of non of the coef are > or < 0.
  ymax <- tryCatch((max(pltdfm$Mean[pltdfm$Mean > 0] + err[pltdfm$Mean > 0]) * 1.05),
                   warning = function(err) return(0))
  ymin <- tryCatch((min(pltdfm$Mean[pltdfm$Mean < 0] - err[pltdfm$Mean < 0]) * 1.15),
                   warning = function(err) return(0))

  if (verbose) cat(paste("VI boxplot being saved to file: ", plot.file.title,".rffs.ifs.plot.pdf...", sep = ""))  # initial message
  loclEnv <- environment()
  baseplt <- ggplot(pltdfm, aes(x = Target, y = Mean), environment = loclEnv) +
    geom_bar(position = "dodge", stat = "identity", color = plot.outlineCol, fill = "gray66")+
    geom_errorbar(aes(ymin = Mean - err, ymax = Mean + err),
                  position = position_dodge(0.9), color = "black", width = plot.errorbarWidth) +
    scale_x_discrete(expand = c(0.05, 0.05)) +
    scale_y_continuous(expand = c(0, 0), limits = c(ymin, ymax),
                       oob = rescale_none, sec.axis = dup_axis()) +
    ggtitle(plot.title) +
    xlab(plot.xLabel) +
    ylab(plot.yLabel) +
    geom_hline(yintercept = 0) +
    theme(panel.background = element_rect(fill = 'white', colour = 'black'),
          panel.border = element_rect(colour = "black", fill = NA, linewidth = 0.5),
          plot.title = element_text(face = "bold", size = plot.titleSize, family = plot.fontType),
          axis.title.x = element_text(face = "bold", size = plot.xLabelSize, family = plot.fontType),
          axis.title.y = element_text(face = "bold", size = plot.yLabelSize, family = plot.fontType),
          axis.title.y.right = element_blank(),
          axis.text.x = element_text(size = plot.xTickLblSize, family = plot.fontType, angle = plot.xAngle,
                                     hjust = plot.xhAlign, vjust = plot.xvAlign),
          axis.text.y = element_text(size = plot.yTickLblSize, family = plot.fontType, hjust = 0.5),
          axis.ticks.x = if(plot.xTickLblSize == 0) element_blank())

  if (plot.fs.line){
    baseplt <- baseplt + geom_hline(yintercept = object$vi_at_threshold, linetype = "dashed", colour = "red")
  }

  if (plot.xTickItalic & plot.xTickBold){
    baseplt <- baseplt +
      theme(axis.text.x = element_text(face = "bold.italic"))
  } else if (plot.xTickItalic & !plot.xTickBold){
    baseplt <- baseplt +
      theme(axis.text.x = element_text(face = "italic"))
  } else if (plot.xTickBold & !plot.xTickItalic){
    baseplt <- baseplt +
      theme(axis.text.x = element_text(face = "bold"))
  }

  if (plot.yTickItalic & plot.yTickBold){
    baseplt <- baseplt +
      theme(axis.text.y  = element_text(face = "bold.italic"))
  } else if (plot.yTickItalic & !plot.yTickBold){
    baseplt <- baseplt +
      theme(axis.text.y = element_text(face = "italic"))
  } else if (plot.yTickBold & !plot.yTickItalic){
    baseplt <- baseplt +
      theme(axis.text.y = element_text(face = "bold"))
  }

  plt <- baseplt

  ## add the right-side y axis
  # grid.newpage()
  # pltgtb <- RBioplot::rightside_y(baseplt)  # not needed anymore
  pltgtb <- (baseplt)

  # export the file and draw a preview
  ggsave(filename = paste(plot.file.title,".rffs.ifs.plot.pdf", sep = ""), plot = pltgtb,
         width = plot.Width, height = plot.Height, units = "mm",dpi = 600)
  grid.draw(pltgtb) # preview
  if (verbose) cat("Done!\n")
}


#' @title rbioFS_rf_initialFS
#'
#' @description Recursive random forest variable importance (vi) and OOB error rate computation.
#' @param objTitle The title for the output data frame. Default is \code{"x_vs_tgt"}
#' @param x Input dataframe or matrix. Make sure to arrange the data with features as column names. Note this excludes the label column.
#' @param y The target (outcome) variable for random forest feature selection.
#' @param nTimes Number of random forest vi computation runs. Default is \code{50} times.
#' @param nTree Number of trees generated for each random forest run. Default is \code{1001} trees.
#' @param mTry Number of random feature pick when building the tree. Default is \code{max(floor(ncol(dfm) / 3), 2)} for classification, and \code{floor(sqrt(ncol(x)))}.
#' @param parallelComputing Wether to use parallel computing or not. Default is \code{TRUE}.
#' @param n_cores Only set when \code{parallelComputing = TRUE}, the number of CPU cores to use. Default is \code{detectCores() - 1}, or the total number cores minus one.
#' @param clusterType Only set when \code{parallelComputing = TRUE}, the type for parallel cluster. Options are \code{"PSOCK"} (all operating systems) and \code{"FORK"} (macOS and Unix-like system only). Default is \code{"PSOCK"}.
#' @param plot If to plot a bargraph to visualize vi and the ranking. Default is \code{TRUE}
#' @param n Number of features to show. Takes integer numbers. Default is \code{"all"} (make sure to include quotation marks).
#' @param ... Additional arguments passed to the plot function \code{\link{rbioFS_rf_initialFS_plot}}.
#' @return Outputs a \code{rf_ifs} object with vi values for each feature and OOB error rate.
#'         When \code{plot = TRUE}, bargraph for the vi is also generated and exported as a \code{.pdf} file.
#'         Detailed results are also exported into a \code{csv} file and a \code{txt} file to the working directory.
#' @details Make sure to arrange data (dfm) with feature (e.g., gene) as variables (i.e., columns), and rownames as sample names.
#' @import ggplot2
#' @import foreach
#' @importFrom randomForest randomForest importance
#' @importFrom rpart rpart prune
#' @importFrom parallel detectCores makeCluster stopCluster
#' @importFrom doParallel registerDoParallel
#' @examples
#' \dontrun{
#' rbioFS_rf_initialFS(training_HCvTC, tgtVar_HCvTC, n = 40, errorbar = "SEM", plotWidth = 400, plotHeight = 200)
#' }
#' @export
rbioFS_rf_initialFS <- function(objTitle = "x_vs_tgt",
                                x, y, nTimes = 50, nTree = 1001,
                                mTry = if (!is.factor(y))
                                  max(floor(ncol(x)/3), 1) else floor(sqrt(ncol(x))),
                                parallelComputing = TRUE, n_cores = parallel::detectCores() - 1, clusterType = c("PSOCK", "FORK"),
                                plot = TRUE,
                                n = "all", ...){
  #### run time initiation
  start_time <- Sys.time()

  #### check arguments
  if (parallelComputing){
    clusterType <- match.arg(clusterType, c("PSOCK", "FORK"))
  }

  #### check the variables
  if (ncol(x) == 1){
    stop("only one feature detected. No need to select.")
  }
  if (any(class(x) == "data.frame")){
    x <- as.matrix(sapply(x, as.numeric))
  }
  ### pepare the target variable
  tgt <- y

  #### recursive RF
  ### load the dataframe/matrix
  training <- x

  ### prepare draw size. this uses down-sampling if the samples are unbalanced
  # nlvl <- length(levels(tgt))
  # size <- min(as.vector(table(tgt))) # down-sampling
  # drawSize <- rep(size, nlvl)

  ### repeating random forest - recursive approach
  # pre-set an empty matrix with the number of columns same as the number of RF runs
  # note that nrow is the number of features, hence the ncol of the training set
  vimtx <- matrix(nrow = ncol(training), ncol = nTimes)
  errmtx <- matrix(nrow = 1, ncol = nTimes)

  ## RF modelling
  rf_modelling_func <- function(i){
    rf <- randomForest::randomForest(x = training, y = tgt, ntree = nTree, mtry = mTry, importance = TRUE,
                                     proximity = TRUE)

    impt <- randomForest::importance(rf, type = 1)
    tmpvimtx <- impt[, 1] # fill the vi matrix
    if (is.factor(tgt)){
      tmperrmtx <- rf$err.rate[nTree, 1] # fill the OOB error rate
    } else {
      tmperrmtx <- rf$mse[nTree]
    }
    lst <- list(tmpvimtx = tmpvimtx, tmperrmtx = tmperrmtx)
  }
  if (!parallelComputing){
    # non-parallel
    tmp <- foreach(i = 1:nTimes) %do% rf_modelling_func(i)
    vimtx <- foreach(i = 1:nTimes, .combine = cbind) %do% tmp[[i]]$tmpvimtx
    errmtx <- foreach(i = 1:nTimes, .combine = cbind) %do% tmp[[i]]$tmperrmtx
  } else { ## parallel computing
    # set up cpu cluster
    n_cores <- n_cores
    cl <- makeCluster(n_cores, type = clusterType)
    registerDoParallel(cl)
    on.exit(stopCluster(cl)) # close connect when exiting the function

    # foreach parallel
    tmp <- foreach(i = 1:nTimes) %dopar% rf_modelling_func(i)
    vimtx <- foreach(i = 1:nTimes, .combine = cbind) %dopar% tmp[[i]]$tmpvimtx
    errmtx <- foreach(i = 1:nTimes, .combine = cbind) %dopar% tmp[[i]]$tmperrmtx
  }
  rownames(vimtx) <- colnames(training)
  colnames(vimtx) <- c(paste("vi", seq(nTimes), sep = "_"))

  rownames(errmtx) <- "OOB_error_rate"
  colnames(errmtx) <- c(paste("OOB_error_tree", seq(nTimes), sep = "_"))

  phase0mtx_vi <- vimtx
  phase0mtx_OOB_err <- errmtx

  ####prepare output vi and OOB error dataframes
  ## prepare the vi dataframe
  fName_vi <- rownames(phase0mtx_vi)
  fMean_vi <- rowMeans(phase0mtx_vi)
  fSD_vi <- apply(phase0mtx_vi, 1, sd)
  fSEM_vi <- sapply(fSD_vi, function(x)x/sqrt(ncol(phase0mtx_vi)))
  tmpdfm_vi <- data.frame(Target = fName_vi, Mean = fMean_vi, SD = fSD_vi, SEM = fSEM_vi, stringsAsFactors = FALSE)
  tmpdfm_vi <- tmpdfm_vi[order(tmpdfm_vi$Mean), ]
  tmpdfm_vi$Target <- factor(tmpdfm_vi$Target, levels = unique(tmpdfm_vi$Target))

  fMean_OOB_err <- rowMeans(phase0mtx_OOB_err)
  fSD_OOB_err <- apply(phase0mtx_OOB_err, 1, sd)
  fSEM_OOB_err <- fSD_OOB_err/sqrt(ncol(phase0mtx_OOB_err))

  # ranked vi dataframe
  outdfm_vi <- data.frame(tmpdfm_vi[order(tmpdfm_vi$Mean, decreasing = TRUE), ],
                          Rank = c(1:nrow(tmpdfm_vi))) # make sure to resort the dataframe in descenting order.

  # OOB dtaframe
  outdfm_OOB_err <- data.frame(Mean = fMean_OOB_err, SD = fSD_OOB_err, SEM = fSEM_OOB_err, stringsAsFactors = FALSE)
  rownames(outdfm_OOB_err) <- paste(nTimes, "trees_OOB_err", sep = "_")

  ## initial feature elimination
  cartTree <- rpart(SD ~ Rank, data = outdfm_vi, cp = 0, minsplit = 2) # CART modelling: classify Rank by SD. Using ANOVA (regression) method.
  mincp <- cartTree$cptable[which(cartTree$cptable[, 4] == min(cartTree$cptable[, 4])) ,1] # extract the minimum cp value
  cartprune <- prune(cartTree, cp = mincp) # prune the tree so that SD values that won't impact Rank classfication are discarded
  minpredv <- min(predict(cartprune)) # obatain the minimum prediciton value (predicted SD) as the SD threshold for Mean

  if (length(which(outdfm_vi$Mean < minpredv)) == 0){ # in the case of VI values don't meet the cut.
    thsd <- ncol(training)
  } else {
    thsd <- min(which(outdfm_vi$Mean < minpredv)) - 1 # compare Mean and SD. Discard all the features with a mean < minimum predicted SD.
  }

  feature_initFS <- as.character(outdfm_vi$Target[1:thsd]) # extract selected features
  training_initFS <- training[, feature_initFS, drop = FALSE] # subsetting the input matrix

  #### export results
  ## run time
  runtime <- Sys.time() - start_time
  if (is.factor(y)){
    err_type <- "OOB"
  } else {
    err_type <- "MSE"
  }

  ## return the vi ranking and OOB err dataframes for the initial feature elimination
  display_time <- strftime(as.POSIXct("00:00:00", format="%H:%M:%S") +
                             runtime, format="%H:%M:%S")
  attributes(display_time, "format") <-"hms"
  outlst <- list(feature_initial_FS = feature_initFS,
                 vi_at_threshold = outdfm_vi[thsd, "Mean"],
                 error_evaluation_type = err_type,
                 ntree = nTree,
                 rf_iteration = nTimes,
                 initial_FS_err_summary = outdfm_OOB_err,
                 vi_summary = outdfm_vi,
                 training_initial_FS = training_initFS,
                 initial_FS_run_time = display_time)
  class(outlst) <- "rf_ifs"

  ## export to files
  write.csv(file = paste0(objTitle, ".initialFS.vi.csv"), outlst$vi_summary, row.names = FALSE)

  sink(file = paste(objTitle,".initialFS.txt",sep = ""), append=FALSE) # dump the results to a file
  print(outlst[!names(outlst) %in% c("training_initial_FS", "vi_summary")])
  sink() # end dump

  ## plot
  if (plot){
    rbioFS_rf_initialFS_plot(object = outlst, n = n, plot.file.title = objTitle,...)
  }

  ## return a dataframe with the vi ranking dataframe
  return(assign(paste(objTitle, "_initial_FS", sep = ""), outlst, envir = .GlobalEnv))
}


#' @title rbioFS_rf_initialFS_v2
#'
#' @description Recursive random forest variable importance (vi) and OOB error rate computation. The v2 version returns the output, as opposed to assigning.
#' @param objTitle The title for the output data frame. Default is \code{"x_vs_tgt"}
#' @param x Input dataframe or matrix. Make sure to arrange the data with features as column names. Note this excludes the label column.
#' @param y The target (outcome) variable for random forest feature selection.
#' @param nTimes Number of random forest vi computation runs. Default is \code{50} times.
#' @param nTree Number of trees generated for each random forest run. Default is \code{1001} trees.
#' @param mTry Number of random feature pick when building the tree. Default is \code{max(floor(ncol(dfm) / 3), 2)} for classification, and \code{floor(sqrt(ncol(x)))}.
#' @param parallelComputing Wether to use parallel computing or not. Default is \code{TRUE}.
#' @param n_cores Only set when \code{parallelComputing = TRUE}, the number of CPU cores to use. Default is \code{detectCores() - 1}, or the total number cores minus one.
#' @param clusterType Only set when \code{parallelComputing = TRUE}, the type for parallel cluster. Options are \code{"PSOCK"} (all operating systems) and \code{"FORK"} (macOS and Unix-like system only). Default is \code{"PSOCK"}.
#' @param plot If to plot a bargraph to visualize vi and the ranking. Default is \code{TRUE}
#' @param n Number of features to show. Takes integer numbers. Default is \code{"all"} (make sure to include quotation marks).
#' @param ... Additional arguments passed to the plot function \code{\link{rbioFS_rf_initialFS_plot}}.
#' @return Outputs a \code{rf_ifs} object with vi values for each feature and OOB error rate.
#'         When \code{plot = TRUE}, bargraph for the vi is also generated and exported as a \code{.pdf} file.
#'         Detailed results are also exported into a \code{csv} file and a \code{txt} file to the working directory.
#' @details Make sure to arrange data (dfm) with feature (e.g., gene) as variables (i.e., columns), and rownames as sample names.
#'          The v2 version returns the output, as opposed to assigning.
#' @import ggplot2
#' @import foreach
#' @importFrom randomForest randomForest importance
#' @importFrom rpart rpart prune
#' @importFrom parallel detectCores makeCluster stopCluster
#' @importFrom doParallel registerDoParallel
#' @examples
#' \dontrun{
#' rbioFS_rf_initialFS(training_HCvTC, tgtVar_HCvTC, n = 40, errorbar = "SEM", plotWidth = 400, plotHeight = 200)
#' }
#' @export
rbioFS_rf_initialFS_v2 <- function(objTitle = "x_vs_tgt",
                                x, y, nTimes = 50, nTree = 1001,
                                mTry = if (!is.factor(y))
                                  max(floor(ncol(x)/3), 1) else floor(sqrt(ncol(x))),
                                parallelComputing = TRUE, n_cores = parallel::detectCores() - 1, clusterType = c("PSOCK", "FORK"),
                                plot = TRUE,
                                n = "all", ...){
  #### run time initiation
  start_time <- Sys.time()

  #### check arguments
  if (parallelComputing){
    clusterType <- match.arg(clusterType, c("PSOCK", "FORK"))
  }

  #### check the variables
  if (ncol(x) == 1){
    stop("only one feature detected. No need to select.")
  }
  if (any(class(x) == "data.frame")){
    x <- as.matrix(sapply(x, as.numeric))
  }
  ### pepare the target variable
  tgt <- y

  #### recursive RF
  ### load the dataframe/matrix
  training <- x

  ### prepare draw size. this uses down-sampling if the samples are unbalanced
  # nlvl <- length(levels(tgt))
  # size <- min(as.vector(table(tgt))) # down-sampling
  # drawSize <- rep(size, nlvl)

  ### repeating random forest - recursive approach
  # pre-set an empty matrix with the number of columns same as the number of RF runs
  # note that nrow is the number of features, hence the ncol of the training set
  vimtx <- matrix(nrow = ncol(training), ncol = nTimes)
  errmtx <- matrix(nrow = 1, ncol = nTimes)

  ## RF modelling
  rf_modelling_func <- function(i){
    rf <- randomForest::randomForest(x = training, y = tgt, ntree = nTree, mtry = mTry, importance = TRUE,
                                     proximity = TRUE)

    impt <- randomForest::importance(rf, type = 1)
    tmpvimtx <- impt[, 1] # fill the vi matrix
    if (is.factor(tgt)){
      tmperrmtx <- rf$err.rate[nTree, 1] # fill the OOB error rate
    } else {
      tmperrmtx <- rf$mse[nTree]
    }
    lst <- list(tmpvimtx = tmpvimtx, tmperrmtx = tmperrmtx)
  }
  if (!parallelComputing){
    # non-parallel
    tmp <- foreach(i = 1:nTimes) %do% rf_modelling_func(i)
    vimtx <- foreach(i = 1:nTimes, .combine = cbind) %do% tmp[[i]]$tmpvimtx
    errmtx <- foreach(i = 1:nTimes, .combine = cbind) %do% tmp[[i]]$tmperrmtx
  } else { ## parallel computing
    # set up cpu cluster
    n_cores <- n_cores
    cl <- makeCluster(n_cores, type = clusterType)
    registerDoParallel(cl)
    on.exit(stopCluster(cl)) # close connect when exiting the function

    # foreach parallel
    tmp <- foreach(i = 1:nTimes) %dopar% rf_modelling_func(i)
    vimtx <- foreach(i = 1:nTimes, .combine = cbind) %dopar% tmp[[i]]$tmpvimtx
    errmtx <- foreach(i = 1:nTimes, .combine = cbind) %dopar% tmp[[i]]$tmperrmtx
  }
  rownames(vimtx) <- colnames(training)
  colnames(vimtx) <- c(paste("vi", seq(nTimes), sep = "_"))

  rownames(errmtx) <- "OOB_error_rate"
  colnames(errmtx) <- c(paste("OOB_error_tree", seq(nTimes), sep = "_"))

  phase0mtx_vi <- vimtx
  phase0mtx_OOB_err <- errmtx

  ####prepare output vi and OOB error dataframes
  ## prepare the vi dataframe
  fName_vi <- rownames(phase0mtx_vi)
  fMean_vi <- rowMeans(phase0mtx_vi)
  fSD_vi <- apply(phase0mtx_vi, 1, sd)
  fSEM_vi <- sapply(fSD_vi, function(x)x/sqrt(ncol(phase0mtx_vi)))
  tmpdfm_vi <- data.frame(Target = fName_vi, Mean = fMean_vi, SD = fSD_vi, SEM = fSEM_vi, stringsAsFactors = FALSE)
  tmpdfm_vi <- tmpdfm_vi[order(tmpdfm_vi$Mean), ]
  tmpdfm_vi$Target <- factor(tmpdfm_vi$Target, levels = unique(tmpdfm_vi$Target))

  fMean_OOB_err <- rowMeans(phase0mtx_OOB_err)
  fSD_OOB_err <- apply(phase0mtx_OOB_err, 1, sd)
  fSEM_OOB_err <- fSD_OOB_err/sqrt(ncol(phase0mtx_OOB_err))

  # ranked vi dataframe
  outdfm_vi <- data.frame(tmpdfm_vi[order(tmpdfm_vi$Mean, decreasing = TRUE), ],
                          Rank = c(1:nrow(tmpdfm_vi))) # make sure to resort the dataframe in descenting order.

  # OOB dtaframe
  outdfm_OOB_err <- data.frame(Mean = fMean_OOB_err, SD = fSD_OOB_err, SEM = fSEM_OOB_err, stringsAsFactors = FALSE)
  rownames(outdfm_OOB_err) <- paste(nTimes, "trees_OOB_err", sep = "_")

  ## initial feature elimination
  cartTree <- rpart(SD ~ Rank, data = outdfm_vi, cp = 0, minsplit = 2) # CART modelling: classify Rank by SD. Using ANOVA (regression) method.
  mincp <- cartTree$cptable[which(cartTree$cptable[, 4] == min(cartTree$cptable[, 4])) ,1] # extract the minimum cp value
  cartprune <- prune(cartTree, cp = mincp) # prune the tree so that SD values that won't impact Rank classfication are discarded
  minpredv <- min(predict(cartprune)) # obatain the minimum prediciton value (predicted SD) as the SD threshold for Mean

  if (length(which(outdfm_vi$Mean < minpredv)) == 0){ # in the case of VI values don't meet the cut.
    thsd <- ncol(training)
  } else {
    thsd <- min(which(outdfm_vi$Mean < minpredv)) - 1 # compare Mean and SD. Discard all the features with a mean < minimum predicted SD.
  }

  feature_initFS <- as.character(outdfm_vi$Target[1:thsd]) # extract selected features
  training_initFS <- training[, feature_initFS, drop = FALSE] # subsetting the input matrix

  #### export results
  ## run time
  runtime <- Sys.time() - start_time
  if (is.factor(y)){
    err_type <- "OOB"
  } else {
    err_type <- "MSE"
  }

  ## return the vi ranking and OOB err dataframes for the initial feature elimination
  display_time <- strftime(as.POSIXct("00:00:00", format="%H:%M:%S") +
                             runtime, format="%H:%M:%S")
  attributes(display_time, "format") <-"hms"
  outlst <- list(feature_initial_FS = feature_initFS,
                 vi_at_threshold = outdfm_vi[thsd, "Mean"],
                 error_evaluation_type = err_type,
                 ntree = nTree,
                 rf_iteration = nTimes,
                 initial_FS_err_summary = outdfm_OOB_err,
                 vi_summary = outdfm_vi,
                 training_initial_FS = training_initFS,
                 initial_FS_run_time = display_time)
  class(outlst) <- "rf_ifs"

  ## export to files
  write.csv(file = paste0(objTitle, ".initialFS.vi.csv"), outlst$vi_summary, row.names = FALSE)

  sink(file = paste(objTitle,".initialFS.txt",sep = ""), append=FALSE) # dump the results to a file
  print(outlst[!names(outlst) %in% c("training_initial_FS", "vi_summary")])
  sink() # end dump

  ## plot
  if (plot){
    rbioFS_rf_initialFS_plot(object = outlst, n = n, plot.file.title = objTitle,...)
  }

  ## return a dataframe with the vi ranking dataframe
  return(outlst)
}


#' @export
print.rf_ifs <- function(x, ...){
  cat("Feature selected from initial selection:\n")
  print(x$feature_initial_FS)
  cat("\n")
  cat("Initial FS run time: ")
  print(x$initial_FS_run_time)
}
