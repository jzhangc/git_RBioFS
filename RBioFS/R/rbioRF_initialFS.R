#' @title rbioFS_rf_initialFS_plot
#'
#' @description Variable importance (VI) plot function for \code{rf_ifs} obejcts generated by \code{rbioFS_rf_initialFS()} or \code{rbioFS()}.
#' @param object A \code{rf_ifs} object. Make sure the object is generated with a \code{validation} section.
#' @param n Number of features to plot. Options are \code{"all"} or an interger. Defatult is \code{"all"}.
#' @param plot.file.title Plot file title prefix. Defatuls is \code{deparse(substitute(object))}.
#' @param plot.title Whether to display plot title on top of the plot. Default is \code{FALSE}.
#' @param plot.fs.line Wether to display the vi line at the feature selection threshold. Default is \code{TRUE}.
#' @param plot.titleSize The font size of the plot title. Default is \code{10}.
#' @param plot.outlineCol The outline colour for the bar gars. Default is \code{"black"}.
#' @param plot.errorbar Set the type of errorbar. Options are standard error of the mean (\code{"SEM"}, \code{"standard error"}, \code{"standard error of the mean"}), or standard deviation (\code{"SD"}, \code{"standard deviation"}), case insensitive. Default is \code{"SEM"}.
#' @param plot.errorbarWidth Set the width for errorbar. Default is \code{0.2}.
#' @param plot.fontType The type of font in the figure. Default is "sans". For all options please refer to R font table, which is avaiable on the website: \url{http://kenstoreylab.com/?page_id=2448}.
#' @param plot.xLabel x axis label. Type with quotation marks. Could be NULL. Default is \code{"Features"}.
#' @param plot.xLabelSize x axis label size. Default is \code{10}.
#' @param plot.xTickLblSize Font size of x axis ticks. Default is \code{10}.
#' @param plot.xTickItalic Set x axis tick font to italic. Default is \code{FALSE}.
#' @param plot.xTickBold Set x axis tick font to bold. Default is \code{FALSE}.
#' @param plot.xAngle The rotation angle (degrees) of the x axis marks. Default is \code{90} - vertical.
#' @param plot.xhAlign The horizontal alignment type of the x axis marks. Options are \code{0}, \code{0.5} and \code{1}. The default value at \code{0} is especially useful when \code{xAngle = 90}.
#' @param plot.xvAlign The vertical alignment type of the x axis marks. Options are \code{0}, \code{0.5} and \code{1}. The default value at \code{0} is especially useful when \code{xAngle = 90}.
#' @param plot.rightsideY If to display the right side y-axis. Default is \code{TRUE}.
#' @param plot.yLabel y axis label. Type with quotation marks. Could be NULL. Default is \code{"Mean Decrease in Accuracy"}.
#' @param plot.yLabelSize y axis label size. Default is \code{10}.
#' @param plot.yTickLblSize Font size of y axis ticks. Default is \code{10}.
#' @param plot.yTickItalic Set y axis tick font to italic. Default is \code{FALSE}.
#' @param plot.yTickBold Set y axis tick font to bold. Default is \code{FALSE}.
#' @param plot.Width The width of the plot (unit: mm). Default is 170. Default will fit most of the cases.
#' @param plot.Height The height of the plot (unit: mm). Default is 150. Default will fit most of the cases.
#' @param verbose Wether to display messages. Default is \code{TRUE}. This will not affect error or warning messeages.
#' @return The function also generates the pdf VI boxplot figure files to the working directory.
#' @importFrom reshape2 melt
#' @importFrom grid grid.newpage grid.draw
#' @importFrom RBioplot rightside_y
#' @importFrom scales rescale_none
#' @import pls
#' @import ggplot2
#' @examples
#' \dontrun{
#' rbioFS_rf_initialFS_plot(object = data_initial_FS, n = "all",plot.title = TRUE, plot.titleSize = 10,
#'                        plot.outlineCol = "black", plot.errorbar = "SEM", plot.errorbarWidth = 0.2,
#'                        plot.errorbarLblSize = 6, plot.fontType = "sans", plot.xLabel = "Features",
#'                        plot.xLabelSize = 10, plot.xTickLblSize = 10, plot.xTickItalic = FALSE,
#'                        plot.xTickBold = FALSE, plot.xAngle = 90, plot.xhAlign = 1, plot.xvAligh = 0.2, plot.rightsideY = TRUE,
#'                        plot.yLabel = "Mean Decrease in Accuracy", plot.yLabelSize = 10, plot.yTickLblSize = 10,
#'                        plot.yTickItalic = FALSE, plot.yTickBold = FALSE, plot.legendSize = 9,
#'                        plot.legendTtl = FALSE, plot.legendTtlSize = 9, plot.Width = 170,
#'                        plot.Height = 150)
#' }
#' @export
rbioFS_rf_initialFS_plot <- function(object, n = "all",
                                     plot.file.title = deparse(substitute(object)),
                                     plot.title = NULL, plot.fs.line = TRUE,
                                     plot.titleSize = 10,
                                     plot.errorbar = "sem", plot.errorbarWidth = 0.2, plot.outlineCol = "black",
                                     plot.fontType = "sans",
                                     plot.xLabel = "Features", plot.xLabelSize = 10,
                                     plot.xAngle = 90, plot.xhAlign = 0.95, plot.xvAlign = 0.5,
                                     plot.xTickLblSize = 10, plot.xTickItalic = FALSE, plot.xTickBold = FALSE,
                                     plot.rightsideY = TRUE,
                                     plot.yLabel = "Feature Importance", plot.yLabelSize = 10, plot.yTickLblSize = 10, plot.yTickItalic = FALSE,
                                     plot.yTickBold = FALSE,
                                     plot.Width = 170, plot.Height = 150,
                                     verbose = TRUE){
  ## check arguments
  if (class(object) != "rf_ifs") stop("object needs to be \"rf_ifs\" class generated by rbioFS_rf_initialFS() or rbioFS()")
  if (is.null(object$vi_at_threshold) & plot.fs.line){
    cat("No vi_at_threshold item detected in the input oject, plot.fs.line set to FALSE. \n")
    plot.fs.line <- FALSE
    }

  ## construuct plot dataframe
  if (any(names(object) %in% "recur_vi_summary")){
    pltdfm <- object$recur_vi_summary
  } else {
    pltdfm <- object$vi_summary
  }

  pltdfm$Target <- factor(pltdfm$Target, unique(pltdfm$Target))
  if (n != "all"){
    if (n %% 1 != 0){
      cat("n is not an integer and has been converted to one.\n")
      n <- as.integer(n)
    }
    if (n > nrow(pltdfm)){
      cat("n > total feature count. proceed without subsetting. \n")
    } else {
      pltdfm <- head(pltdfm, n)
    }
  }

  ## plot
  if (plot.xTickLblSize == 0) cat("Due to plot.xTickLblSize = 0, x-axis ticks are hidden for the VI boxplot.\n")

  # error bar
  if (tolower(plot.errorbar) %in% c("sem", "standard error", "standard error of the mean")){  # error bar
    err <- pltdfm$SEM
  } else if (tolower(plot.errorbar) %in% c("sd", "standard deviation")){
    err <- pltdfm$SD
  }

  # use tryCatch in the case of non of the coef are > or < 0.
  ymax <- tryCatch((max(pltdfm$Mean[pltdfm$Mean > 0] + err[pltdfm$Mean > 0]) * 1.05),
                   warning = function(err) return(0))
  ymin <- tryCatch((min(pltdfm$Mean[pltdfm$Mean < 0] - err[pltdfm$Mean < 0]) * 1.15),
                   warning = function(err) return(0))

  if (verbose) cat(paste("VI boxplot being saved to file: ", plot.file.title,".rffs.ifs.plot.pdf...", sep = ""))  # initial message
  loclEnv <- environment()
  baseplt <- ggplot(pltdfm, aes(x = Target, y = Mean), environment = loclEnv) +
    geom_bar(position = "dodge", stat = "identity", color = plot.outlineCol, fill = "gray66")+
    geom_errorbar(aes(ymin = Mean - err, ymax = Mean + err),
                  position = position_dodge(0.9), color = "black", width = plot.errorbarWidth) +
    scale_x_discrete(expand = c(0.05, 0.05)) +
    scale_y_continuous(expand = c(0, 0), limits = c(ymin, ymax),
                       oob = rescale_none) +
    ggtitle(plot.title) +
    xlab(plot.xLabel) +
    ylab(plot.yLabel) +
    geom_hline(yintercept = 0) +
    theme(panel.background = element_rect(fill = 'white', colour = 'black'),
          panel.border = element_rect(colour = "black", fill = NA, size = 0.5),
          plot.title = element_text(face = "bold", size = plot.titleSize, family = plot.fontType),
          axis.title.x = element_text(face = "bold", size = plot.xLabelSize, family = plot.fontType),
          axis.title.y = element_text(face = "bold", size = plot.yLabelSize, family = plot.fontType),
          axis.text.x = element_text(size = plot.xTickLblSize, family = plot.fontType, angle = plot.xAngle,
                                     hjust = plot.xhAlign, vjust = plot.xvAlign),
          axis.text.y = element_text(size = plot.yTickLblSize, family = plot.fontType, hjust = 0.5),
          axis.ticks.x = if(plot.xTickLblSize == 0) element_blank())

  if (plot.fs.line){
    baseplt <- baseplt + geom_hline(yintercept = object$vi_at_threshold, linetype = "dashed", colour = "red")
  }

  if (plot.xTickItalic & plot.xTickBold){
    baseplt <- baseplt +
      theme(axis.text.x = element_text(face = "bold.italic"))
  } else if (plot.xTickItalic & !plot.xTickBold){
    baseplt <- baseplt +
      theme(axis.text.x = element_text(face = "italic"))
  } else if (plot.xTickBold & !plot.xTickItalic){
    baseplt <- baseplt +
      theme(axis.text.x = element_text(face = "bold"))
  }

  if (plot.yTickItalic & plot.yTickBold){
    baseplt <- baseplt +
      theme(axis.text.y  = element_text(face = "bold.italic"))
  } else if (plot.yTickItalic & !plot.yTickBold){
    baseplt <- baseplt +
      theme(axis.text.y = element_text(face = "italic"))
  } else if (plot.yTickBold & !plot.yTickItalic){
    baseplt <- baseplt +
      theme(axis.text.y = element_text(face = "bold"))
  }

  plt <- baseplt

  ## add the right-side y axis
  # grid.newpage()
  pltgtb <- RBioplot::rightside_y(baseplt)

  # export the file and draw a preview
  ggsave(filename = paste(plot.file.title,".rffs.ifs.plot.pdf", sep = ""), plot = pltgtb,
         width = plot.Width, height = plot.Height, units = "mm",dpi = 600)
  grid.draw(pltgtb) # preview
  if (verbose) cat("Done!\n")
}

#' @title rbioFS_rf_initialFS
#'
#' @description Recursive random froest variable importance (vi) and OOB error rate computation.
#' @param objTitle The title for the output data frame. Default is \code{"x_vs_tgt"}
#' @param x Input dataframe or matrix. Make sure to arrange the data with features as column names. Note this excludes the label column.
#' @param targetVar The target variable for random forest feature selection. This is a factor object.
#' @param nTimes Number of random forest vi computation runs. Default is \code{50} times.
#' @param nTree Number of trees generated for each random forest run. Default is \code{1001} trees.
#' @param mTry Number of random feature pick when building the tree. Default is \code{max(floor(ncol(dfm) / 3), 2)}.
#' @param multicore If to use parallel computing. Default is \code{TRUE}.
#' @param plot If to plot a bargraph to visualize vi and the ranking. Default is \code{TRUE}
#' @param n Number of features to show. Takes integer numbers. Default is \code{"all"} (make sure to include quotation marks).
#' @param ... Additional arguments passed to the plot function \code{\link{rbioFS_rf_initialFS_plot}}.
#' @return Outputs a \code{rf_ifs} object with vi values for each feature and OOB error rate. When \code{TRUE}, bargraph for the vi is also generated and exported as a \code{.pdf} file.
#' @details Make sure to arrange data (dfm) with feature (e.g., gene) as variables (i.e., columns), and rownames as sample names.
#' @import ggplot2
#' @import foreach
#' @importFrom randomForest randomForest importance
#' @importFrom rpart rpart prune
#' @importFrom parallel detectCores makeCluster stopCluster
#' @importFrom doParallel registerDoParallel
#' @examples
#' \dontrun{
#' rbioFS_rf_initialFS(training_HCvTC, tgtVar_HCvTC, n = 40, errorbar = "SEM", plotWidth = 400, plotHeight = 200)
#' }
#' @export
rbioFS_rf_initialFS <- function(objTitle = "x_vs_tgt",
                             x, targetVar, nTimes = 50, nTree = 1001, mTry = max(floor(ncol(x) / 3), 2),
                             multicore = TRUE,
                             plot = TRUE,
                             n = "all", ...){

  #### check the variables
  if (ncol(x) == 1){
    stop("only one feature detected. No need to select.")
  }
  if (class(x) == "data.frame"){
    x <- as.matrix(sapply(x, as.numeric))
  }

  #### recursive RF
  ### load the dataframe/matrix
  training <- x

  ### pepare the target variable
  tgt <- factor(as.character(targetVar), levels = unique(targetVar))

  ### prepare draw size. this uses down-sampling if the samples are unbalanced
  nlvl <- length(levels(tgt))
  size <- min(as.vector(table(tgt))) # down-sampling
  drawSize <- rep(size, nlvl)

  ### repeating random forest - recursive approach
  # pre-set an empty matrix with the number of columns same as the number of RF runs
  # note that nrow is the number of features, hence the ncol of the training set
  vimtx <- matrix(nrow = ncol(training), ncol = nTimes)
  errmtx <- matrix(nrow = 1, ncol = nTimes)

  if (!multicore){ ## signle core computing: recursive structure
    tmpFunc <- function(n, m, tmptimes, tmpvimtx, tmperrmtx, tmpTraining, tmpTgt,
                        tmpTree, tmpTry, tmpSize){

      tmploclEnv <- environment() # save the environment local to tmpFunc
      if (n == 0){
        rownames(tmpvimtx) <- colnames(tmpTraining)
        colnames(tmpvimtx) <- c(paste("vi", seq(m - 1), sep = "_"))
        rownames(tmperrmtx) <- "OOB_error_rate"
        colnames(tmperrmtx) <- c(paste("OOB_error_tree", seq(m - 1), sep = "_"))

        tmplst <- list(raw_vi = tmpvimtx, raw_OOB_error = tmperrmtx)
        return(tmplst)

      } else {
        rf <- randomForest(x = tmpTraining, y = tmpTgt, ntree = tmpTree, mtry = tmpTry, importance = TRUE,
                           proximity = TRUE, drawSize = tmpSize)
        impt <- importance(rf, type = 1)
        tmpvimtx[, m] <- impt[, 1] # fill the vi matrix
        tmperrmtx[, m] <- rf$err.rate[tmptimes, 1] # fill the OOB error rate
        tmpFunc(n - 1, m + 1, tmptimes, tmpvimtx, tmperrmtx, tmpTraining, tmpTgt,
                tmpTree, tmpTry, tmpSize)
      }
    }

    lst <- tmpFunc(n = nTimes, m = 1, tmptimes = nTree, tmpvimtx = vimtx, tmperrmtx = errmtx, tmpTraining = training, tmpTgt = tgt,
                   tmpTree = nTree, tmpTry = mTry, tmpSize = drawSize)

    phase0mtx_vi <- lst$raw_vi
    phase0mtx_OOB_err <- lst$raw_OOB_error

  } else { ## parallel computing
    # set up cpu cluster
    n_cores <- detectCores() - 1
    cl <- makeCluster(n_cores)
    registerDoParallel(cl)
    on.exit(stopCluster(cl)) # close connect when exiting the function

    # recursive RF using par-apply functions
    tmpfunc2 <- function(i){
      rf <- randomForest::randomForest(x = training, y = tgt, ntree = nTree, mtry = mTry, importance = TRUE,
                                       proximity = TRUE, drawSize = drawSize)

      impt <- randomForest::importance(rf, type = 1)
      tmpvimtx <- impt[, 1] # fill the vi matrix
      tmperrmtx <- rf$err.rate[nTree, 1] # fill the OOB error rate
      lst <- list(tmpvimtx = tmpvimtx, tmperrmtx = tmperrmtx)
    }

    # foreach parallel
    tmp <- foreach(i = 1:nTimes) %dopar% tmpfunc2(i)
    vimtx <- foreach(i = 1:nTimes, .combine = cbind) %dopar% tmp[[i]]$tmpvimtx
    errmtx <- foreach(i = 1:nTimes, .combine = cbind) %dopar% tmp[[i]]$tmperrmtx

    rownames(vimtx) <- colnames(training)
    colnames(vimtx) <- c(paste("vi", seq(nTimes), sep = "_"))

    rownames(errmtx) <- "OOB_error_rate"
    colnames(errmtx) <- c(paste("OOB_error_tree", seq(nTimes), sep = "_"))

    phase0mtx_vi <- vimtx
    phase0mtx_OOB_err <- errmtx
  }

  ####prepare output vi and OOB error dataframes
  ## prepare the vi dataframe
  fName_vi <- rownames(phase0mtx_vi)
  fMean_vi <- rowMeans(phase0mtx_vi)
  fSD_vi <- apply(phase0mtx_vi, 1, sd)
  fSEM_vi <- sapply(fSD_vi, function(x)x/sqrt(ncol(phase0mtx_vi)))
  tmpdfm_vi <- data.frame(Target = fName_vi, Mean = fMean_vi, SD = fSD_vi, SEM = fSEM_vi, stringsAsFactors = FALSE)
  tmpdfm_vi <- tmpdfm_vi[order(tmpdfm_vi$Mean), ]
  tmpdfm_vi$Target <- factor(tmpdfm_vi$Target, levels = unique(tmpdfm_vi$Target))

  fMean_OOB_err <- rowMeans(phase0mtx_OOB_err)
  fSD_OOB_err <- apply(phase0mtx_OOB_err, 1, sd)
  fSEM_OOB_err <- fSD_OOB_err/sqrt(ncol(phase0mtx_OOB_err))

  # ranked vi dataframe
  outdfm_vi <- data.frame(tmpdfm_vi[order(tmpdfm_vi$Mean, decreasing = TRUE), ],
                          Rank = c(1:nrow(tmpdfm_vi))) # make sure to resort the dataframe in descenting order.

  # OOB dtaframe
  outdfm_OOB_err <- data.frame(Mean = fMean_OOB_err, SD = fSD_OOB_err, SEM = fSEM_OOB_err, stringsAsFactors = FALSE)
  rownames(outdfm_OOB_err) <- paste(nTimes, "trees_OOB_err", sep = "_")

  ## initial feature elimination
  cartTree <- rpart(SD ~ Rank, data = outdfm_vi, cp = 0, minsplit = 2) # CART modelling: classify Rank by SD. Using ANOVA (regression) method.
  mincp <- cartTree$cptable[which(cartTree$cptable[, 4] == min(cartTree$cptable[, 4])) ,1] # extract the minimum cp value
  cartprune <- prune(cartTree, cp = mincp) # prune the tree so that SD values that won't impact Rank classfication are discarded
  minpredv <- min(predict(cartprune)) # obatain the minimum prediciton value (predicted SD) as the SD threshold for Mean

  if (length(which(outdfm_vi$Mean < minpredv)) == 0){ # in the case of VI values don't meet the cut.
    thsd <- ncol(training)
  } else {
    thsd <- min(which(outdfm_vi$Mean < minpredv)) - 1 # compare Mean and SD. Discard all the features with a mean < minimum predicted SD.
  }

  feature_initFS <- as.character(outdfm_vi$Target[1:thsd]) # extract selected features
  training_initFS <- training[, feature_initFS, drop = FALSE] # subsetting the input matrix

  ## return the vi ranking and OOB err dataframes for the initial feature elimination
  outlst <- list(feature_initial_FS = feature_initFS,
                 vi_at_threshold = outdfm_vi[thsd, "Mean"],
                 vi_summary = outdfm_vi,
                 initial_FS_OOB_err_summary = outdfm_OOB_err,
                 training_initial_FS = training_initFS)

  sink(file = paste(objTitle,".initialFS.txt",sep = ""), append=FALSE) # dump the results to a file
  print(outlst)
  sink() # end dump
  class(outlst) <- "rf_ifs"

  ## plot
  if (plot){
    rbioFS_rf_initial_FS_plot(object = outlst, n = n, plot.file.title = objTitle,...)
  }

  ## return a dataframe with the vi ranking dataframe
  return(assign(paste(objTitle, "_initial_FS", sep = ""), outlst, envir = .GlobalEnv))
}


#' @export
print.rf_ifs <- function(x, ...){
  cat("Feature selected from initial selection:\n")
  print(x$feature_initial_FS)
  cat("\n\n")
}
